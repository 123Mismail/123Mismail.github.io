"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[901],{1468(n,t,e){e.r(t),e.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"c10-real-time-algorithms","title":"Chapter 10: Real-Time Control Algorithms for Humanoid Robotics","description":"Learning Outcomes","source":"@site/chapters/c10-real-time-algorithms.md","sourceDirName":".","slug":"/c10-real-time-algorithms","permalink":"/chapters/c10-real-time-algorithms","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"id":"c10-real-time-algorithms","title":"Chapter 10: Real-Time Control Algorithms for Humanoid Robotics","sidebar_label":"C10: Real-Time Algorithms","sidebar_position":10},"sidebar":"tutorialSidebar","previous":{"title":"C9: Real-Time Control","permalink":"/chapters/c9-real-time-control"},"next":{"title":"C11: Sensor Fusion","permalink":"/chapters/c11-sensor-fusion"}}');var o=e(4848),r=e(8453);const s={id:"c10-real-time-algorithms",title:"Chapter 10: Real-Time Control Algorithms for Humanoid Robotics",sidebar_label:"C10: Real-Time Algorithms",sidebar_position:10},a="Chapter 10: Real-Time Control Algorithms for Humanoid Robotics",l={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Overview",id:"overview",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Model Predictive Control for Humanoid Robots",id:"model-predictive-control-for-humanoid-robots",level:2},{value:"Linear Inverted Pendulum Model (LIPM) for Balance Control",id:"linear-inverted-pendulum-model-lipm-for-balance-control",level:3},{value:"Trajectory Optimization with Real-Time Constraints",id:"trajectory-optimization-with-real-time-constraints",level:3},{value:"Whole-Body Control Framework",id:"whole-body-control-framework",level:2},{value:"Quadratic Programming for Whole-Body Control",id:"quadratic-programming-for-whole-body-control",level:3},{value:"Real-Time Optimization Techniques",id:"real-time-optimization-techniques",level:2},{value:"Efficient QP Solving for Real-Time Applications",id:"efficient-qp-solving-for-real-time-applications",level:3},{value:"Summary",id:"summary",level:2},{value:"Review Questions",id:"review-questions",level:2}];function _(n){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"chapter-10-real-time-control-algorithms-for-humanoid-robotics",children:"Chapter 10: Real-Time Control Algorithms for Humanoid Robotics"})}),"\n",(0,o.jsx)(t.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,o.jsx)(t.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Implement"})," Model Predictive Control (MPC) algorithms optimized for real-time humanoid robot control"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Design"})," whole-body control frameworks that integrate multiple control objectives simultaneously"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Deploy"})," trajectory optimization algorithms with real-time constraints for humanoid motion planning"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Evaluate"})," computational complexity and timing performance of control algorithms on embedded systems"]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(t.p,{children:"Chapter 9 established the foundational concepts of real-time control systems and embedded hardware platforms for humanoid robotics. Building on that foundation, this chapter delves into the sophisticated control algorithms that enable humanoid robots to perform complex, dynamic behaviors in real-time."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Real-time control algorithms"})," for humanoid robotics must balance computational efficiency with control performance to meet strict timing constraints while achieving complex behaviors. Unlike simple PID controllers that operate on individual joints, humanoid robots require advanced algorithms that consider whole-body dynamics, balance constraints, contact forces, and multiple simultaneous objectives."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Model Predictive Control (MPC)"})," represents a key approach for humanoid control, predicting future system behavior over a finite horizon and optimizing control inputs to achieve desired objectives while respecting constraints. ",(0,o.jsx)(t.strong,{children:"Whole-body control"})," frameworks integrate multiple control tasks (balance, manipulation, locomotion) into unified optimization problems that consider the full robot dynamics."]}),"\n",(0,o.jsx)(t.p,{children:"This chapter explores these advanced control algorithms, focusing on their real-time implementation, computational optimization, and practical deployment on embedded systems. You will learn to implement MPC controllers, design whole-body control frameworks, and optimize algorithms for real-time performance on resource-constrained platforms."}),"\n",(0,o.jsx)(t.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Model Predictive Control (MPC)"}),": Control strategy that uses a model of the system to predict future behavior and optimize control inputs over a finite horizon"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Whole-Body Control"}),": Framework that formulates multiple control objectives (balance, manipulation, locomotion) as a single optimization problem"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Quadratic Programming (QP)"}),": Mathematical optimization technique used to solve control problems with quadratic cost functions and linear constraints"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Zero Moment Point (ZMP)"}),": Point where the net moment of ground reaction forces is zero, used for balance control in humanoid robots"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Centroidal Dynamics"}),": Simplified model of robot dynamics focusing on the center of mass and angular momentum"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Trajectory Optimization"}),": Process of finding optimal robot trajectories that minimize cost functions while satisfying constraints"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Real-Time Iterative Algorithms"}),": Optimization methods that provide approximate solutions within real-time constraints by performing limited iterations"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Constraint Handling"}),": Techniques for managing physical limits, contact constraints, and safety requirements in real-time control"]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"model-predictive-control-for-humanoid-robots",children:"Model Predictive Control for Humanoid Robots"}),"\n",(0,o.jsx)(t.p,{children:"Model Predictive Control (MPC) is particularly well-suited for humanoid robotics due to its ability to handle constraints and predict future behavior:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Current State  \u2502\u2500\u2500\u2500\u25ba\u2502  MPC Prediction  \u2502\u2500\u2500\u2500\u25ba\u2502  Optimal Control \u2502\n\u2502  (Position,     \u2502    \u2502  Model (Horizon \u2502    \u2502  Inputs         \u2502\n\u2502   Velocity,     \u2502    \u2502  N steps)       \u2502    \u2502  (Joint Torques \u2502\n\u2502   Balance)      \u2502    \u2502                 \u2502    \u2502   or Forces)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                       \u2502                        \u2502\n         \u25bc                       \u25bc                        \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  State Estimation\u2502    \u2502  Constraint     \u2502    \u2502  < 5ms           \u2502\n\u2502  (IMU, Encoders)\u2502    \u2502  Optimization   \u2502    \u2502  Computation     \u2502\n\u2502                 \u2502    \u2502  (QP Solver)     \u2502    \u2502  Time           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,o.jsx)(t.p,{children:"MPC for humanoid robots typically uses simplified models like the Linear Inverted Pendulum Model (LIPM) or centroidal dynamics to make the optimization tractable for real-time execution."}),"\n",(0,o.jsx)(t.h3,{id:"linear-inverted-pendulum-model-lipm-for-balance-control",children:"Linear Inverted Pendulum Model (LIPM) for Balance Control"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-cpp",children:"// lipm_mpc.cpp - Linear Inverted Pendulum Model for humanoid balance control\n#include <Eigen/Dense>\n#include <vector>\n#include <chrono>\n\nnamespace humanoid_control {\n\nclass LIPMMPC {\nprivate:\n    // Robot parameters\n    double gravity_;\n    double height_;  // Constant CoM height\n    double omega_;   // Natural frequency sqrt(g/h)\n\n    // MPC parameters\n    int horizon_steps_;\n    double dt_;      // Control timestep\n    double Q_pos_;   // State cost weight\n    double R_control_; // Control cost weight\n\n    // State prediction matrices\n    Eigen::MatrixXd A_discrete_;\n    Eigen::MatrixXd B_discrete_;\n\n    // Optimization matrices\n    Eigen::MatrixXd H_qp_;  // Hessian matrix\n    Eigen::VectorXd f_qp_;  // Linear term\n    Eigen::MatrixXd A_ineq_; // Inequality constraints\n    Eigen::VectorXd b_ineq_; // Inequality constraint bounds\n\npublic:\n    LIPMMPC(double com_height, double dt, int horizon)\n        : gravity_(9.81), height_(com_height), dt_(dt), horizon_steps_(horizon) {\n\n        // Calculate natural frequency\n        omega_ = std::sqrt(gravity_ / height_);\n\n        // Initialize cost weights\n        Q_pos_ = 10.0;      // High weight on position tracking\n        R_control_ = 0.1;   // Lower weight on control effort\n\n        // Pre-compute discrete-time system matrices\n        compute_discrete_matrices();\n\n        // Initialize optimization matrices\n        initialize_optimization_matrices();\n    }\n\n    void compute_discrete_matrices() {\n        // Continuous-time LIPM system: x_dot = A*x + B*u\n        // where x = [px; vx] (CoM position and velocity)\n        // and u = px_ref (desired CoM position)\n\n        // Continuous system matrices\n        Eigen::MatrixXd A_cont(2, 2);\n        A_cont << 0, 1,\n                  std::pow(omega_, 2), 0;\n\n        Eigen::MatrixXd B_cont(2, 1);\n        B_cont << 0,\n                  -std::pow(omega_, 2);\n\n        // Discretize using matrix exponential\n        Eigen::MatrixXd AB_cont(2, 3);\n        AB_cont.topLeftCorner(2, 2) = A_cont;\n        AB_cont.topRightCorner(2, 1) = B_cont;\n\n        AB_cont *= dt_;\n        Eigen::MatrixXd AB_disc = AB_cont.exp();\n\n        A_discrete_ = AB_disc.topLeftCorner(2, 2);\n        B_discrete_ = AB_disc.topRightCorner(2, 1);\n    }\n\n    void initialize_optimization_matrices() {\n        int n_states = 2;  // px, vx\n        int n_controls = 1; // px_ref\n        int total_vars = horizon_steps_ * n_controls;\n\n        // Initialize Hessian matrix (quadratic cost terms)\n        H_qp_ = Eigen::MatrixXd::Zero(total_vars, total_vars);\n        f_qp_ = Eigen::VectorXd::Zero(total_vars);\n\n        // Initialize constraint matrices\n        int total_state_vars = (horizon_steps_ + 1) * n_states;\n        A_ineq_ = Eigen::MatrixXd::Zero(2 * horizon_steps_, total_vars + total_state_vars);\n        b_ineq_ = Eigen::VectorXd::Zero(2 * horizon_steps_);\n    }\n\n    Eigen::VectorXd solve_mpc(const Eigen::Vector2d& current_state,\n                             const std::vector<Eigen::Vector2d>& reference_trajectory) {\n        // Formulate and solve the QP problem\n        // min: 0.5 * x^T * H * x + f^T * x\n        // s.t: A*x <= b\n\n        // This is a simplified implementation\n        // In practice, you would use a QP solver like OSQP or qpOASES\n\n        // Build the QP problem matrices based on current state and reference\n        build_qp_matrices(current_state, reference_trajectory);\n\n        // Solve the QP problem (in practice, use a dedicated solver)\n        Eigen::VectorXd solution = solve_qp();\n\n        // Extract the first control input (MPC principle)\n        return solution.head(1);\n    }\n\nprivate:\n    void build_qp_matrices(const Eigen::Vector2d& current_state,\n                          const std::vector<Eigen::Vector2d>& reference_trajectory) {\n        // Build the QP cost and constraint matrices\n        // This involves expanding the prediction model over the horizon\n        // and forming the quadratic cost function\n\n        int n_states = 2;\n        int n_controls = 1;\n        int total_vars = horizon_steps_ * n_controls;\n\n        // Reset matrices\n        H_qp_.setZero();\n        f_qp_.setZero();\n\n        Eigen::Vector2d state = current_state;\n\n        for (int k = 0; k < horizon_steps_; ++k) {\n            // Predict state evolution: x[k+1] = A*x[k] + B*u[k]\n            // For LIPM: x = [px; vx]\n\n            // Cost on state deviation from reference\n            double pos_ref = reference_trajectory[k][0];\n            double vel_ref = reference_trajectory[k][1];\n\n            // Quadratic terms for state cost\n            H_qp_(k, k) += Q_pos_ * B_discrete_(0, 0) * B_discrete_(0, 0);  // Simplified\n\n            // Linear terms for state cost\n            f_qp_(k) += -2.0 * Q_pos_ * (state(0) - pos_ref) * B_discrete_(0, 0);\n\n            // Control effort cost\n            H_qp_(k, k) += R_control_;\n\n            // Predict next state using control input (simplified)\n            state = A_discrete_ * state;  // Assuming u=0 for prediction\n        }\n    }\n\n    Eigen::VectorXd solve_qp() {\n        // In a real implementation, this would call a QP solver\n        // For this example, we'll return a simple approximation\n\n        // Use conjugate gradient or other iterative method\n        // to solve H*x = -f subject to constraints\n        Eigen::VectorXd solution = -H_qp_.inverse() * f_qp_;\n        return solution;\n    }\n\npublic:\n    // Real-time safe method to get next control command\n    double get_next_control_command(const Eigen::Vector2d& current_state,\n                                   const std::vector<Eigen::Vector2d>& reference_trajectory) {\n        Eigen::VectorXd solution = solve_mpc(current_state, reference_trajectory);\n\n        // Return first element (current control command)\n        return solution(0);\n    }\n};\n\n} // namespace humanoid_control\n"})}),"\n",(0,o.jsx)(t.h3,{id:"trajectory-optimization-with-real-time-constraints",children:"Trajectory Optimization with Real-Time Constraints"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-cpp",children:"// trajectory_optimizer.cpp - Real-time trajectory optimization for humanoid motion\n#include <Eigen/Dense>\n#include <vector>\n#include <chrono>\n#include <thread>\n\nnamespace humanoid_control {\n\nclass RealTimeTrajectoryOptimizer {\nprivate:\n    // Robot dynamics parameters\n    double mass_;\n    Eigen::Matrix3d inertia_;\n\n    // Optimization parameters\n    int num_waypoints_;\n    double dt_;\n    double max_computation_time_ms_;\n\n    // Cost function weights\n    double weight_position_;\n    double weight_velocity_;\n    double weight_acceleration_;\n    double weight_inequality_constraints_;\n\n    // Constraint parameters\n    Eigen::Vector3d com_min_limit_;\n    Eigen::Vector3d com_max_limit_;\n    double max_velocity_limit_;\n    double max_acceleration_limit_;\n\npublic:\n    RealTimeTrajectoryOptimizer(double robot_mass, const Eigen::Matrix3d& robot_inertia,\n                              int waypoints, double timestep, double max_comp_time_ms = 2.0)\n        : mass_(robot_mass), inertia_(robot_inertia), num_waypoints_(waypoints),\n          dt_(timestep), max_computation_time_ms_(max_comp_time_ms) {\n\n        // Initialize cost weights\n        weight_position_ = 1.0;\n        weight_velocity_ = 0.1;\n        weight_acceleration_ = 0.01;\n        weight_inequality_constraints_ = 100.0;\n\n        // Initialize constraint limits\n        com_min_limit_ << -0.5, -0.5, 0.5;   // Example limits\n        com_max_limit_ << 0.5, 0.5, 1.5;\n        max_velocity_limit_ = 1.0;    // m/s\n        max_acceleration_limit_ = 5.0; // m/s^2\n    }\n\n    struct TrajectorySolution {\n        std::vector<Eigen::Vector3d> positions;\n        std::vector<Eigen::Vector3d> velocities;\n        std::vector<Eigen::Vector3d> accelerations;\n        bool success;\n        double computation_time_ms;\n    };\n\n    TrajectorySolution optimize_trajectory(\n        const Eigen::Vector3d& start_pos,\n        const Eigen::Vector3d& start_vel,\n        const Eigen::Vector3d& goal_pos,\n        const std::vector<Eigen::Vector3d>& via_points = {},\n        const std::vector<Eigen::Vector3d>& obstacle_positions = {}) {\n\n        auto start_time = std::chrono::high_resolution_clock::now();\n\n        // Initialize trajectory with straight-line interpolation\n        std::vector<Eigen::Vector3d> trajectory_positions =\n            initialize_trajectory(start_pos, goal_pos);\n\n        // Iteratively optimize the trajectory\n        TrajectorySolution solution;\n        solution.positions = trajectory_positions;\n        solution.velocities.resize(num_waypoints_);\n        solution.accelerations.resize(num_waypoints_);\n\n        // Calculate velocities and accelerations\n        for (int i = 0; i < num_waypoints_; ++i) {\n            if (i == 0) {\n                solution.velocities[i] = start_vel;\n                solution.accelerations[i] = Eigen::Vector3d::Zero();\n            } else {\n                solution.velocities[i] = (solution.positions[i] - solution.positions[i-1]) / dt_;\n\n                if (i > 1) {\n                    solution.accelerations[i] = (solution.velocities[i] - solution.velocities[i-1]) / dt_;\n                }\n            }\n        }\n\n        // Iteratively refine the trajectory to minimize cost while satisfying constraints\n        bool converged = false;\n        int iteration = 0;\n        const int max_iterations = 50;  // Limit iterations for real-time safety\n\n        while (!converged && iteration < max_iterations) {\n            // Check if we're approaching the time limit\n            auto current_time = std::chrono::high_resolution_clock::now();\n            double elapsed_ms = std::chrono::duration<double, std::milli>(\n                current_time - start_time).count();\n\n            if (elapsed_ms > max_computation_time_ms_ * 0.8) {  // Use 80% of allowed time\n                break;\n            }\n\n            // Apply gradient descent step to optimize trajectory\n            converged = optimize_step(solution, start_pos, goal_pos, via_points, obstacle_positions);\n            iteration++;\n        }\n\n        auto end_time = std::chrono::high_resolution_clock::now();\n        solution.computation_time_ms = std::chrono::duration<double, std::milli>(\n            end_time - start_time).count();\n        solution.success = (solution.computation_time_ms < max_computation_time_ms_);\n\n        return solution;\n    }\n\nprivate:\n    std::vector<Eigen::Vector3d> initialize_trajectory(\n        const Eigen::Vector3d& start_pos,\n        const Eigen::Vector3d& goal_pos) {\n\n        std::vector<Eigen::Vector3d> trajectory(num_waypoints_);\n\n        for (int i = 0; i < num_waypoints_; ++i) {\n            double t = static_cast<double>(i) / (num_waypoints_ - 1);\n            trajectory[i] = start_pos + t * (goal_pos - start_pos);\n        }\n\n        return trajectory;\n    }\n\n    bool optimize_step(TrajectorySolution& solution,\n                      const Eigen::Vector3d& start_pos,\n                      const Eigen::Vector3d& goal_pos,\n                      const std::vector<Eigen::Vector3d>& via_points,\n                      const std::vector<Eigen::Vector3d>& obstacle_positions) {\n\n        // Calculate gradients of cost function with respect to each waypoint\n        std::vector<Eigen::Vector3d> gradients(num_waypoints_);\n\n        for (int i = 0; i < num_waypoints_; ++i) {\n            gradients[i] = calculate_gradient(solution, i, start_pos, goal_pos,\n                                            via_points, obstacle_positions);\n        }\n\n        // Apply gradient descent step\n        double step_size = 0.01;  // Small step for stability\n\n        for (int i = 0; i < num_waypoints_; ++i) {\n            // Don't modify start point\n            if (i == 0) continue;\n\n            solution.positions[i] -= step_size * gradients[i];\n\n            // Apply position constraints\n            solution.positions[i] = apply_position_constraints(solution.positions[i]);\n        }\n\n        // Recalculate velocities and accelerations\n        for (int i = 1; i < num_waypoints_; ++i) {\n            solution.velocities[i] = (solution.positions[i] - solution.positions[i-1]) / dt_;\n\n            if (i > 1) {\n                solution.accelerations[i] = (solution.velocities[i] - solution.velocities[i-1]) / dt_;\n\n                // Apply velocity and acceleration constraints\n                solution.velocities[i] = apply_velocity_constraints(solution.velocities[i]);\n                solution.accelerations[i] = apply_acceleration_constraints(solution.accelerations[i]);\n            }\n        }\n\n        // Check for convergence (simplified check)\n        double max_gradient_norm = 0.0;\n        for (const auto& grad : gradients) {\n            max_gradient_norm = std::max(max_gradient_norm, grad.norm());\n        }\n\n        return max_gradient_norm < 1e-6;  // Converged if gradients are small\n    }\n\n    Eigen::Vector3d calculate_gradient(const TrajectorySolution& solution, int waypoint_idx,\n                                      const Eigen::Vector3d& start_pos,\n                                      const Eigen::Vector3d& goal_pos,\n                                      const std::vector<Eigen::Vector3d>& via_points,\n                                      const std::vector<Eigen::Vector3d>& obstacle_positions) {\n\n        Eigen::Vector3d gradient = Eigen::Vector3d::Zero();\n\n        // Gradient due to position cost (distance to reference trajectory)\n        if (waypoint_idx == num_waypoints_ - 1) {\n            // Goal position cost\n            gradient += 2.0 * weight_position_ * (solution.positions[waypoint_idx] - goal_pos);\n        }\n\n        // Gradient due to velocity smoothness\n        if (waypoint_idx > 0 && waypoint_idx < num_waypoints_ - 1) {\n            // Velocity difference from neighboring points\n            Eigen::Vector3d vel_next = (solution.positions[waypoint_idx + 1] -\n                                       solution.positions[waypoint_idx]) / dt_;\n            Eigen::Vector3d vel_prev = (solution.positions[waypoint_idx] -\n                                       solution.positions[waypoint_idx - 1]) / dt_;\n\n            Eigen::Vector3d acc = (vel_next - vel_prev) / dt_;\n            gradient += 2.0 * weight_acceleration_ * acc;\n        }\n\n        // Gradient due to obstacle avoidance\n        for (const auto& obstacle : obstacle_positions) {\n            Eigen::Vector3d to_obstacle = solution.positions[waypoint_idx] - obstacle;\n            double distance = to_obstacle.norm();\n\n            if (distance < 0.5) {  // Within safety radius\n                double force_magnitude = weight_inequality_constraints_ / (distance * distance + 1e-6);\n                Eigen::Vector3d repulsive_force = force_magnitude * to_obstacle.normalized();\n                gradient += repulsive_force;\n            }\n        }\n\n        return gradient;\n    }\n\n    Eigen::Vector3d apply_position_constraints(const Eigen::Vector3d& pos) {\n        Eigen::Vector3d constrained_pos = pos;\n\n        // Apply position limits\n        for (int i = 0; i < 3; ++i) {\n            constrained_pos(i) = std::max(com_min_limit_(i),\n                                         std::min(constrained_pos(i), com_max_limit_(i)));\n        }\n\n        return constrained_pos;\n    }\n\n    Eigen::Vector3d apply_velocity_constraints(const Eigen::Vector3d& vel) {\n        double vel_norm = vel.norm();\n        if (vel_norm > max_velocity_limit_) {\n            return (vel / vel_norm) * max_velocity_limit_;\n        }\n        return vel;\n    }\n\n    Eigen::Vector3d apply_acceleration_constraints(const Eigen::Vector3d& acc) {\n        double acc_norm = acc.norm();\n        if (acc_norm > max_acceleration_limit_) {\n            return (acc / acc_norm) * max_acceleration_limit_;\n        }\n        return acc;\n    }\n};\n\n} // namespace humanoid_control\n"})}),"\n",(0,o.jsx)(t.h2,{id:"whole-body-control-framework",children:"Whole-Body Control Framework"}),"\n",(0,o.jsx)(t.p,{children:"Whole-body control integrates multiple control objectives into unified optimization problems:"}),"\n",(0,o.jsx)(t.h3,{id:"quadratic-programming-for-whole-body-control",children:"Quadratic Programming for Whole-Body Control"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-cpp",children:'// whole_body_control.cpp - Whole-body control using quadratic programming\n#include <Eigen/Dense>\n#include <vector>\n#include <memory>\n\nnamespace humanoid_control {\n\nclass WholeBodyController {\nprivate:\n    // Robot properties\n    int num_joints_;\n    double robot_mass_;\n    Eigen::Vector3d com_position_;\n\n    // Control hierarchy\n    struct Task {\n        std::string name;\n        int priority;\n        Eigen::MatrixXd task_jacobian;\n        Eigen::VectorXd desired_values;\n        Eigen::VectorXd current_values;\n        double weight;\n    };\n\n    std::vector<Task> tasks_;\n\n    // QP formulation matrices\n    Eigen::MatrixXd H_qp_;  // Hessian (cost matrix)\n    Eigen::VectorXd f_qp_;  // Linear term\n    Eigen::MatrixXd A_eq_;  // Equality constraints\n    Eigen::VectorXd b_eq_;  // Equality constraint values\n    Eigen::MatrixXd A_ineq_; // Inequality constraints\n    Eigen::VectorXd b_ineq_; // Inequality constraint bounds\n\n    // Joint limits and constraints\n    Eigen::VectorXd joint_position_limits_min_;\n    Eigen::VectorXd joint_position_limits_max_;\n    Eigen::VectorXd joint_velocity_limits_;\n    Eigen::VectorXd joint_torque_limits_;\n\npublic:\n    WholeBodyController(int num_joints, double robot_mass)\n        : num_joints_(num_joints), robot_mass_(robot_mass) {\n\n        // Initialize constraint vectors\n        joint_position_limits_min_ = Eigen::VectorXd::Constant(num_joints_, -M_PI);\n        joint_position_limits_max_ = Eigen::VectorXd::Constant(num_joints_, M_PI);\n        joint_velocity_limits_ = Eigen::VectorXd::Constant(num_joints_, 10.0);  // rad/s\n        joint_torque_limits_ = Eigen::VectorXd::Constant(num_joints_, 100.0);   // Nm\n\n        // Initialize QP matrices (sizes will be set during solve)\n        H_qp_ = Eigen::MatrixXd(0, 0);\n        f_qp_ = Eigen::VectorXd(0);\n        A_eq_ = Eigen::MatrixXd(0, 0);\n        b_eq_ = Eigen::VectorXd(0);\n        A_ineq_ = Eigen::MatrixXd(0, 0);\n        b_ineq_ = Eigen::VectorXd(0);\n    }\n\n    void add_task(const std::string& name, int priority,\n                  const Eigen::MatrixXd& jacobian,\n                  const Eigen::VectorXd& desired_values,\n                  double weight = 1.0) {\n\n        Task task;\n        task.name = name;\n        task.priority = priority;\n        task.task_jacobian = jacobian;\n        task.desired_values = desired_values;\n        task.current_values = Eigen::VectorXd::Zero(desired_values.size());\n        task.weight = weight;\n\n        tasks_.push_back(task);\n\n        // Sort tasks by priority (higher priority first)\n        std::sort(tasks_.begin(), tasks_.end(),\n                 [](const Task& a, const Task& b) {\n                     return a.priority > b.priority;\n                 });\n    }\n\n    struct WBCSolution {\n        Eigen::VectorXd joint_positions;\n        Eigen::VectorXd joint_velocities;\n        Eigen::VectorXd joint_torques;\n        std::vector<double> task_errors;\n        bool success;\n    };\n\n    WBCSolution solve(const Eigen::VectorXd& current_positions,\n                     const Eigen::VectorXd& current_velocities,\n                     const Eigen::VectorXd& current_torques) {\n\n        WBCSolution solution;\n        solution.joint_positions = current_positions;\n        solution.joint_velocities = current_velocities;\n        solution.joint_torques = current_torques;\n        solution.success = false;\n\n        if (tasks_.empty()) {\n            solution.success = true;\n            return solution;\n        }\n\n        try {\n            // Build the QP problem based on control hierarchy\n            build_hierarchical_qp(current_positions, current_velocities);\n\n            // Solve the QP problem (in practice, use OSQP, qpOASES, or similar)\n            Eigen::VectorXd decision_variables = solve_qp_problem();\n\n            // Extract solution\n            int total_vars = decision_variables.size();\n            if (total_vars >= num_joints_) {\n                solution.joint_torques = decision_variables.head(num_joints_);\n                solution.success = true;\n            }\n\n            // Calculate task errors\n            solution.task_errors.resize(tasks_.size());\n            for (size_t i = 0; i < tasks_.size(); ++i) {\n                Eigen::VectorXd task_result = tasks_[i].task_jacobian * solution.joint_torques;\n                solution.task_errors[i] = (task_result - tasks_[i].desired_values).norm();\n            }\n\n        } catch (const std::exception& e) {\n            // Handle QP solver errors\n            solution.success = false;\n        }\n\n        return solution;\n    }\n\nprivate:\n    void build_hierarchical_qp(const Eigen::VectorXd& current_positions,\n                              const Eigen::VectorXd& current_velocities) {\n\n        // Calculate total number of variables and constraints\n        int total_variables = num_joints_;  // Joint torques\n        int total_constraints = 0;\n\n        // Count constraints from each task\n        for (const auto& task : tasks_) {\n            total_constraints += task.desired_values.size();\n        }\n\n        // Add joint limit constraints\n        total_constraints += 2 * num_joints_;  // Position and velocity limits\n\n        // Resize matrices\n        H_qp_ = Eigen::MatrixXd::Zero(total_variables, total_variables);\n        f_qp_ = Eigen::VectorXd::Zero(total_variables);\n        A_eq_ = Eigen::MatrixXd::Zero(0, total_variables);  // Will be built task by task\n        b_eq_ = Eigen::VectorXd::Zero(0);                   // Will be built task by task\n        A_ineq_ = Eigen::MatrixXd::Zero(total_constraints, total_variables);\n        b_ineq_ = Eigen::VectorXd::Zero(total_constraints);\n\n        // Build cost function: minimize weighted sum of task errors and regularization\n        // J = sum_i (weight_i * ||J_i * tau - x_des_i||^2) + reg_weight * ||tau||^2\n\n        double regularization_weight = 0.001;  // Small regularization for stability\n        H_qp_ = regularization_weight * Eigen::MatrixXd::Identity(total_variables, total_variables);\n        f_qp_ = Eigen::VectorXd::Zero(total_variables);\n\n        int constraint_row = 0;\n\n        // Add each task to the optimization problem\n        for (const auto& task : tasks_) {\n            int task_size = task.desired_values.size();\n\n            // Add task to cost function: ||J * tau - x_des||^2\n            // Expands to: tau^T * (J^T * J) * tau - 2 * x_des^T * J * tau + x_des^T * x_des\n            H_qp_ += task.weight * task.task_jacobian.transpose() * task.task_jacobian;\n            f_qp_ -= 2.0 * task.weight * task.desired_values.transpose() * task.task_jacobian;\n\n            // Add task equality constraints (for hierarchical control)\n            // For now, we\'ll use inequality constraints to allow some flexibility\n            A_ineq_.block(constraint_row, 0, task_size, total_variables) = task.task_jacobian;\n            b_ineq_.segment(constraint_row, task_size) = task.desired_values + 0.1;  // Allow small tolerance\n\n            constraint_row += task_size;\n        }\n\n        // Add joint limit constraints\n        // Position limits: q_min <= q <= q_max\n        for (int i = 0; i < num_joints_; ++i) {\n            A_ineq_(constraint_row, i) = 1.0;\n            b_ineq_(constraint_row) = joint_position_limits_max_(i);\n            constraint_row++;\n\n            A_ineq_(constraint_row, i) = -1.0;\n            b_ineq_(constraint_row) = -joint_position_limits_min_(i);\n            constraint_row++;\n        }\n    }\n\n    Eigen::VectorXd solve_qp_problem() {\n        // In a real implementation, this would call a QP solver\n        // For this example, we\'ll use Eigen\'s LDLT solver for the KKT system\n\n        // Form KKT system: [H A^T; A 0] * [x; lambda] = [-f; b]\n        // This is a simplified approach - real systems use specialized QP solvers\n\n        int n = H_qp_.rows();\n        int m = A_ineq_.rows();\n\n        if (n == 0) {\n            return Eigen::VectorXd::Zero(num_joints_);\n        }\n\n        // For inequality constraints, we\'ll use a simplified approach\n        // In practice, active-set or interior-point methods are used\n\n        // Use Eigen\'s least squares solver as an approximation\n        // min: ||H_qp_ * x + f_qp_||^2 + ||A_ineq_ * x - b_ineq_||^2\n        Eigen::MatrixXd combined_A = Eigen::MatrixXd::Zero(n + m, n);\n        combined_A.topRows(n) = H_qp_;\n        combined_A.bottomRows(m) = A_ineq_;\n\n        Eigen::VectorXd combined_b = Eigen::VectorXd::Zero(n + m);\n        combined_b.topRows(n) = -f_qp_;\n        combined_b.bottomRows(m) = b_ineq_;\n\n        // Solve using least squares\n        Eigen::VectorXd solution = combined_A.colPivHouseholderQr().solve(combined_b);\n\n        return solution.head(num_joints_);  // Return only joint torques\n    }\n};\n\n// Example usage of whole-body control for humanoid\nclass HumanoidWBC {\nprivate:\n    std::unique_ptr<WholeBodyController> wbc_controller_;\n\n    // Task-specific jacobians (would be computed from robot kinematics)\n    Eigen::MatrixXd com_jacobian_;\n    Eigen::MatrixXd left_foot_jacobian_;\n    Eigen::MatrixXd right_foot_jacobian_;\n    Eigen::MatrixXd left_hand_jacobian_;\n    Eigen::MatrixXd right_hand_jacobian_;\n    Eigen::MatrixXd head_jacobian_;\n\npublic:\n    HumanoidWBC(int num_joints, double robot_mass) {\n        wbc_controller_ = std::make_unique<WholeBodyController>(num_joints, robot_mass);\n\n        // Initialize jacobian matrices (sizes depend on your robot)\n        // These would be computed from forward kinematics in a real implementation\n        com_jacobian_ = Eigen::MatrixXd::Zero(6, num_joints);      // 6 DoF: pos + orientation\n        left_foot_jacobian_ = Eigen::MatrixXd::Zero(6, num_joints);\n        right_foot_jacobian_ = Eigen::MatrixXd::Zero(6, num_joints);\n        left_hand_jacobian_ = Eigen::MatrixXd::Zero(6, num_joints);\n        right_hand_jacobian_ = Eigen::MatrixXd::Zero(6, num_joints);\n        head_jacobian_ = Eigen::MatrixXd::Zero(6, num_joints);\n    }\n\n    void setup_balance_control_tasks() {\n        // High priority: Balance control (ZMP or COM control)\n        Eigen::VectorXd com_desired = Eigen::VectorXd::Zero(6);  // [x, y, z, roll, pitch, yaw]\n        com_desired.segment(0, 3) << 0.0, 0.0, 0.8;  // Desired CoM position (x, y, height)\n\n        wbc_controller_->add_task("balance_control", 100, com_jacobian_, com_desired, 10.0);\n    }\n\n    void setup_foot_placement_tasks() {\n        // Medium priority: Foot placement for walking\n        Eigen::VectorXd left_foot_desired = Eigen::VectorXd::Zero(6);\n        Eigen::VectorXd right_foot_desired = Eigen::VectorXd::Zero(6);\n\n        // Set desired foot positions for walking pattern\n        wbc_controller_->add_task("left_foot_placement", 80, left_foot_jacobian_, left_foot_desired, 5.0);\n        wbc_controller_->add_task("right_foot_placement", 80, right_foot_jacobian_, right_foot_desired, 5.0);\n    }\n\n    void setup_manipulation_tasks() {\n        // Lower priority: Arm manipulation tasks\n        Eigen::VectorXd left_hand_desired = Eigen::VectorXd::Zero(6);\n        Eigen::VectorXd right_hand_desired = Eigen::VectorXd::Zero(6);\n\n        wbc_controller_->add_task("left_hand_control", 50, left_hand_jacobian_, left_hand_desired, 1.0);\n        wbc_controller_->add_task("right_hand_control", 50, right_hand_jacobian_, right_hand_desired, 1.0);\n    }\n\n    WholeBodyController::WBCSolution execute_control(\n        const Eigen::VectorXd& current_positions,\n        const Eigen::VectorXd& current_velocities,\n        const Eigen::VectorXd& current_torques) {\n\n        return wbc_controller_->solve(current_positions, current_velocities, current_torques);\n    }\n};\n\n} // namespace humanoid_control\n'})}),"\n",(0,o.jsx)(t.h2,{id:"real-time-optimization-techniques",children:"Real-Time Optimization Techniques"}),"\n",(0,o.jsx)(t.h3,{id:"efficient-qp-solving-for-real-time-applications",children:"Efficient QP Solving for Real-Time Applications"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-cpp",children:"// real_time_qp.cpp - Efficient QP solving techniques for real-time control\n#include <Eigen/Dense>\n#include <chrono>\n#include <thread>\n\nnamespace humanoid_control {\n\nclass RealTimeQP {\nprivate:\n    // Warm-start variables for iterative solvers\n    Eigen::VectorXd previous_solution_;\n    bool has_previous_solution_;\n\n    // Pre-allocated matrices to avoid allocation during real-time loop\n    Eigen::MatrixXd H_cached_;\n    Eigen::VectorXd g_cached_;\n    Eigen::MatrixXd A_cached_;\n    Eigen::VectorXd b_cached_;\n\n    // Iterative solver parameters\n    int max_iterations_;\n    double tolerance_;\n    double penalty_parameter_;  // For penalty methods\n\npublic:\n    RealTimeQP(int max_vars, int max_constraints)\n        : max_iterations_(20), tolerance_(1e-4), penalty_parameter_(1000.0),\n          has_previous_solution_(false) {\n\n        // Pre-allocate matrices\n        previous_solution_ = Eigen::VectorXd::Zero(max_vars);\n        H_cached_ = Eigen::MatrixXd::Zero(max_vars, max_vars);\n        g_cached_ = Eigen::VectorXd::Zero(max_vars);\n        A_cached_ = Eigen::MatrixXd::Zero(max_constraints, max_vars);\n        b_cached_ = Eigen::VectorXd::Zero(max_constraints);\n    }\n\n    struct QPSolution {\n        Eigen::VectorXd solution;\n        bool success;\n        int iterations;\n        double computation_time_ms;\n    };\n\n    QPSolution solve_warm_start(const Eigen::MatrixXd& H, const Eigen::VectorXd& g,\n                               const Eigen::MatrixXd& A_eq, const Eigen::VectorXd& b_eq,\n                               const Eigen::MatrixXd& A_ineq, const Eigen::VectorXd& b_ineq,\n                               const Eigen::VectorXd& initial_guess) {\n\n        auto start_time = std::chrono::high_resolution_clock::now();\n\n        // Use the initial guess (warm start) to speed up convergence\n        Eigen::VectorXd x = initial_guess;\n\n        // Check if the initial guess is feasible\n        bool feasible = check_feasibility(A_eq, b_eq, A_ineq, b_ineq, x);\n\n        if (!feasible) {\n            // Find a feasible point first\n            x = find_feasible_point(A_eq, b_eq, A_ineq, b_ineq, initial_guess);\n        }\n\n        // Iterative QP solver using active-set method (simplified)\n        QPSolution solution;\n        solution.solution = x;\n        solution.success = true;\n        solution.iterations = 0;\n\n        // Use projected gradient method for real-time efficiency\n        for (int iter = 0; iter < max_iterations_; ++iter) {\n            solution.iterations = iter + 1;\n\n            // Compute gradient: g + H*x\n            Eigen::VectorXd gradient = g + H * x;\n\n            // Project gradient onto feasible set (simplified)\n            Eigen::VectorXd search_direction = -gradient;\n\n            // Line search with constraint checking\n            double step_size = 1.0;\n            Eigen::VectorXd new_x = x + step_size * search_direction;\n\n            // Check constraints and reduce step if needed\n            int max_step_attempts = 5;\n            for (int attempt = 0; attempt < max_step_attempts; ++attempt) {\n                if (check_feasibility(A_eq, b_eq, A_ineq, b_ineq, new_x)) {\n                    break;\n                }\n                step_size *= 0.5;\n                new_x = x + step_size * search_direction;\n            }\n\n            // Update solution\n            Eigen::VectorXd x_old = x;\n            x = new_x;\n\n            // Check for convergence\n            if ((x - x_old).norm() < tolerance_) {\n                break;\n            }\n        }\n\n        solution.solution = x;\n\n        auto end_time = std::chrono::high_resolution_clock::now();\n        solution.computation_time_ms = std::chrono::duration<double, std::milli>(\n            end_time - start_time).count();\n\n        return solution;\n    }\n\nprivate:\n    bool check_feasibility(const Eigen::MatrixXd& A_eq, const Eigen::VectorXd& b_eq,\n                          const Eigen::MatrixXd& A_ineq, const Eigen::VectorXd& b_ineq,\n                          const Eigen::VectorXd& x) {\n\n        // Check equality constraints: ||A_eq * x - b_eq|| < tolerance\n        if (A_eq.rows() > 0) {\n            Eigen::VectorXd eq_violation = A_eq * x - b_eq;\n            if (eq_violation.norm() > 1e-3) {\n                return false;\n            }\n        }\n\n        // Check inequality constraints: A_ineq * x <= b_ineq\n        if (A_ineq.rows() > 0) {\n            Eigen::VectorXd ineq_violation = A_ineq * x - b_ineq;\n            for (int i = 0; i < ineq_violation.size(); ++i) {\n                if (ineq_violation(i) > 1e-3) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    Eigen::VectorXd find_feasible_point(const Eigen::MatrixXd& A_eq, const Eigen::VectorXd& b_eq,\n                                       const Eigen::MatrixXd& A_ineq, const Eigen::VectorXd& b_ineq,\n                                       const Eigen::VectorXd& initial_guess) {\n\n        // Use penalty method to find a feasible point\n        // min: ||A_eq * x - b_eq||^2 + sum(max(0, A_ineq * x - b_ineq)^2)\n\n        Eigen::VectorXd x = initial_guess;\n        int max_feasibility_iterations = 50;\n\n        for (int iter = 0; iter < max_feasibility_iterations; ++iter) {\n            // Compute constraint violations\n            Eigen::VectorXd eq_violation = A_eq * x - b_eq;\n            Eigen::VectorXd ineq_violation = A_ineq * x - b_ineq;\n\n            // Apply penalty for inequality violations\n            for (int i = 0; i < ineq_violation.size(); ++i) {\n                if (ineq_violation(i) > 0) {\n                    ineq_violation(i) = ineq_violation(i) * penalty_parameter_;\n                } else {\n                    ineq_violation(i) = 0;\n                }\n            }\n\n            // Gradient of penalty function\n            Eigen::VectorXd grad = 2.0 * A_eq.transpose() * eq_violation +\n                                  2.0 * A_ineq.transpose() * ineq_violation;\n\n            // Gradient descent step\n            x -= 0.01 * grad;  // Fixed step size for real-time safety\n\n            // Check if feasible now\n            if (check_feasibility(A_eq, b_eq, A_ineq, b_ineq, x)) {\n                break;\n            }\n        }\n\n        return x;\n    }\n};\n\n} // namespace humanoid_control\n"})}),"\n",(0,o.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsxs)(t.p,{children:["Real-time control algorithms for humanoid robotics enable complex behaviors through sophisticated optimization techniques that balance computational efficiency with control performance. ",(0,o.jsx)(t.strong,{children:"Model Predictive Control (MPC)"})," provides predictive capabilities for balance and trajectory following, while ",(0,o.jsx)(t.strong,{children:"Whole-Body Control"})," frameworks integrate multiple control objectives into unified optimization problems."]}),"\n",(0,o.jsx)(t.p,{children:"Key capabilities include:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"MPC algorithms"})," using simplified models (LIPM) for tractable real-time optimization"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Trajectory optimization"})," with iterative methods that meet timing constraints"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Whole-body control"})," using hierarchical QP formulations for multi-task coordination"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Real-time optimization"})," techniques including warm-starting and iterative methods"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"In Chapter 11, we will explore sensor fusion techniques that provide the state estimation necessary for these advanced control algorithms, including IMU integration, visual-inertial odometry, and multi-sensor data fusion for humanoid robotics applications."}),"\n",(0,o.jsx)(t.h2,{id:"review-questions",children:"Review Questions"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Conceptual"}),": Compare the computational complexity of Model Predictive Control versus PID control for humanoid balance. What are the trade-offs in terms of performance and real-time feasibility?"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Applied"}),": Implement a real-time MPC controller for humanoid balance that runs at 200Hz on an embedded platform, including constraint handling and warm-starting techniques."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Structural"}),": Analyze the integration challenges when combining whole-body control with trajectory optimization, particularly regarding computational load distribution across control hierarchy levels."]}),"\n"]}),"\n"]})]})}function d(n={}){const{wrapper:t}={...(0,r.R)(),...n.components};return t?(0,o.jsx)(t,{...n,children:(0,o.jsx)(_,{...n})}):_(n)}},8453(n,t,e){e.d(t,{R:()=>s,x:()=>a});var i=e(6540);const o={},r=i.createContext(o);function s(n){const t=i.useContext(r);return i.useMemo(function(){return"function"==typeof n?n(t):{...t,...n}},[t,n])}function a(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),i.createElement(r.Provider,{value:t},n.children)}}}]);
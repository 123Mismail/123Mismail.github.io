"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[905],{1851(n,e,i){i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"c12-whole-body-control","title":"Chapter 12: Whole-Body Control for Humanoid Robotics","description":"Learning Outcomes","source":"@site/chapters/c12-whole-body-control.md","sourceDirName":".","slug":"/c12-whole-body-control","permalink":"/chapters/c12-whole-body-control","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"C11: Sensor Fusion","permalink":"/chapters/c11-sensor-fusion"},"next":{"title":"Chapter 13: ZMP Walking and Balance Control for Humanoid Robotics","permalink":"/chapters/c13-zmp-walking"}}');var t=i(4848),r=i(8453);const a={},s="Chapter 12: Whole-Body Control for Humanoid Robotics",l={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Overview",id:"overview",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"12.1 Mathematical Foundations of Whole-Body Control",id:"121-mathematical-foundations-of-whole-body-control",level:2},{value:"12.1.1 Optimization Formulation",id:"1211-optimization-formulation",level:3},{value:"12.1.2 Hierarchical Optimization",id:"1212-hierarchical-optimization",level:3},{value:"12.2 Implementation with Quadratic Programming",id:"122-implementation-with-quadratic-programming",level:2},{value:"12.2.1 Control Architecture",id:"1221-control-architecture",level:3},{value:"12.2.2 C++ Implementation Example",id:"1222-c-implementation-example",level:3},{value:"12.3 Hierarchical Task Prioritization",id:"123-hierarchical-task-prioritization",level:2},{value:"12.3.1 Priority-Based Task Allocation",id:"1231-priority-based-task-allocation",level:3},{value:"12.3.2 Dynamic Task Reconfiguration",id:"1232-dynamic-task-reconfiguration",level:3},{value:"12.4 Real-Time Performance Considerations",id:"124-real-time-performance-considerations",level:2},{value:"12.4.1 Computational Complexity Analysis",id:"1241-computational-complexity-analysis",level:3},{value:"12.4.2 Optimization Strategies",id:"1242-optimization-strategies",level:3},{value:"12.5 Integration with ROS 2 Control Framework",id:"125-integration-with-ros-2-control-framework",level:2},{value:"12.5.1 ROS 2 Controller Interface",id:"1251-ros-2-controller-interface",level:3},{value:"12.6 Practical Considerations and Limitations",id:"126-practical-considerations-and-limitations",level:2},{value:"12.6.1 Numerical Stability",id:"1261-numerical-stability",level:3},{value:"12.6.2 Sensor Integration",id:"1262-sensor-integration",level:3},{value:"Summary",id:"summary",level:2},{value:"Review Questions",id:"review-questions",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"chapter-12-whole-body-control-for-humanoid-robotics",children:"Chapter 12: Whole-Body Control for Humanoid Robotics"})}),"\n",(0,t.jsx)(e.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,t.jsx)(e.p,{children:"By the end of this chapter, students will be able to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Understand the principles of whole-body control for humanoid robots"}),"\n",(0,t.jsx)(e.li,{children:"Implement quadratic programming (QP) based controllers for multi-task optimization"}),"\n",(0,t.jsx)(e.li,{children:"Design hierarchical control frameworks for simultaneous task execution"}),"\n",(0,t.jsx)(e.li,{children:"Apply kinematic and dynamic constraints in whole-body control systems"}),"\n",(0,t.jsx)(e.li,{children:"Evaluate the computational complexity and real-time performance of whole-body controllers"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(e.p,{children:"Whole-body control represents a sophisticated approach to managing the complex dynamics of humanoid robots by simultaneously optimizing multiple control objectives across all degrees of freedom. This chapter explores the mathematical foundations of whole-body control, focusing on quadratic programming formulations that enable humanoid robots to perform multiple tasks simultaneously while respecting physical constraints. We'll examine hierarchical optimization techniques that prioritize critical tasks while achieving secondary objectives, and explore practical implementations using state-of-the-art control frameworks."}),"\n",(0,t.jsx)(e.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Quadratic Programming (QP)"}),": Mathematical optimization technique for solving whole-body control problems with quadratic cost functions and linear constraints"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Task Prioritization"}),": Hierarchical approach to control where primary tasks (like balance) take precedence over secondary tasks (like reaching)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Constraint Handling"}),": Integration of joint limits, torque limits, and contact constraints into the control formulation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Kinematic vs Dynamic Control"}),": Trade-offs between position-based and force-based control approaches"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Real-time Optimization"}),": Computational considerations for achieving stable control at high frequencies"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"121-mathematical-foundations-of-whole-body-control",children:"12.1 Mathematical Foundations of Whole-Body Control"}),"\n",(0,t.jsx)(e.p,{children:"Whole-body control addresses the challenge of coordinating multiple control objectives simultaneously in humanoid robots. Unlike traditional decoupled control approaches, whole-body control formulates the problem as a single optimization task that considers all degrees of freedom and constraints together."}),"\n",(0,t.jsx)(e.h3,{id:"1211-optimization-formulation",children:"12.1.1 Optimization Formulation"}),"\n",(0,t.jsx)(e.p,{children:"The whole-body control problem can be formulated as a quadratic program:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"min_u ||J * u - b||\xb2 + \u03bb * ||u||\xb2\nsubject to: A_eq * u = b_eq\n           A_ineq * u <= b_ineq\n"})}),"\n",(0,t.jsx)(e.p,{children:"Where:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"u"})," represents the control variables (joint velocities, forces, or accelerations)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"J"})," is the task Jacobian matrix mapping control variables to task space"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"b"})," is the desired task velocity or acceleration"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"\u03bb"})," is a regularization parameter for numerical stability"]}),"\n",(0,t.jsx)(e.li,{children:"Equality and inequality constraints represent physical limits and requirements"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"1212-hierarchical-optimization",children:"12.1.2 Hierarchical Optimization"}),"\n",(0,t.jsx)(e.p,{children:"In practice, whole-body control often uses hierarchical optimization to handle multiple tasks with different priorities:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Level 1: min ||J\u2081 * u - b\u2081||\xb2 (Primary task)\nLevel 2: min ||J\u2082 * u - b\u2082||\xb2 (Secondary task)\nsubject to: ||J\u2081 * u - b\u2081||\xb2 \u2264 \u03b5\u2081 (Primary task constraint)\n"})}),"\n",(0,t.jsx)(e.p,{children:"This approach ensures that higher-priority tasks are satisfied while optimizing lower-priority objectives within the remaining solution space."}),"\n",(0,t.jsx)(e.h2,{id:"122-implementation-with-quadratic-programming",children:"12.2 Implementation with Quadratic Programming"}),"\n",(0,t.jsx)(e.h3,{id:"1221-control-architecture",children:"12.2.1 Control Architecture"}),"\n",(0,t.jsx)(e.p,{children:"The whole-body control architecture consists of several key components:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Task Definition Layer"}),": Defines control objectives (position, orientation, force)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Constraint Formulation"}),": Translates physical limits into optimization constraints"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"QP Solver"}),": Solves the optimization problem in real-time"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Integration Layer"}),": Converts control outputs to actuator commands"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"1222-c-implementation-example",children:"12.2.2 C++ Implementation Example"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'// WholeBodyController.h\n#pragma once\n#include <Eigen/Dense>\n#include <qpOASES.hpp>\n#include <vector>\n\nstruct Task {\n    Eigen::MatrixXd jacobian;\n    Eigen::VectorXd desired;\n    double weight;\n    int priority;\n\n    Task(const Eigen::MatrixXd& J, const Eigen::VectorXd& d,\n         double w, int p) : jacobian(J), desired(d), weight(w), priority(p) {}\n};\n\nclass WholeBodyController {\nprivate:\n    Eigen::VectorXd joint_positions_;\n    Eigen::VectorXd joint_velocities_;\n    Eigen::VectorXd joint_torques_;\n\n    std::vector<Task> tasks_;\n    Eigen::MatrixXd joint_limits_;\n    Eigen::VectorXd torque_limits_;\n\n    // QP problem variables\n    Eigen::MatrixXd hessian_;\n    Eigen::VectorXd gradient_;\n    Eigen::MatrixXd constraint_matrix_;\n    Eigen::VectorXd constraint_bounds_;\n\n    // QP solver\n    qpOASES::QProblem qp_solver_;\n\npublic:\n    WholeBodyController(int num_dofs);\n    void addTask(const Task& task);\n    void setJointLimits(const Eigen::MatrixXd& limits);\n    void setTorqueLimits(const Eigen::VectorXd& limits);\n    Eigen::VectorXd computeControl();\n    void updateState(const Eigen::VectorXd& q,\n                    const Eigen::VectorXd& q_dot);\n\nprivate:\n    void buildOptimizationProblem();\n    void solveQP();\n    void applyConstraints();\n};\n\n// WholeBodyController.cpp\n#include "WholeBodyController.h"\n#include <iostream>\n\nWholeBodyController::WholeBodyController(int num_dofs)\n    : joint_positions_(Eigen::VectorXd::Zero(num_dofs)),\n      joint_velocities_(Eigen::VectorXd::Zero(num_dofs)),\n      joint_torques_(Eigen::VectorXd::Zero(num_dofs)),\n      joint_limits_(Eigen::MatrixXd::Zero(2, num_dofs)),\n      torque_limits_(Eigen::VectorXd::Zero(num_dofs)),\n      qp_solver_(num_dofs, 0) // No constraints initially\n{\n    // Initialize with reasonable defaults\n    joint_limits_.row(0) = -M_PI * Eigen::VectorXd::Ones(num_dofs); // lower bounds\n    joint_limits_.row(1) = M_PI * Eigen::VectorXd::Ones(num_dofs);  // upper bounds\n    torque_limits_ = 100.0 * Eigen::VectorXd::Ones(num_dofs);       // 100 Nm limits\n\n    // Initialize QP solver options\n    qpOASES::Options options;\n    options.setToMPC();\n    options.printLevel = qpOASES::PL_NONE;\n    qp_solver_.setOptions(options);\n}\n\nvoid WholeBodyController::addTask(const Task& task) {\n    tasks_.push_back(task);\n}\n\nvoid WholeBodyController::setJointLimits(const Eigen::MatrixXd& limits) {\n    joint_limits_ = limits;\n}\n\nvoid WholeBodyController::setTorqueLimits(const Eigen::VectorXd& limits) {\n    torque_limits_ = limits;\n}\n\nvoid WholeBodyController::updateState(const Eigen::VectorXd& q,\n                                     const Eigen::VectorXd& q_dot) {\n    joint_positions_ = q;\n    joint_velocities_ = q_dot;\n}\n\nvoid WholeBodyController::buildOptimizationProblem() {\n    int num_dofs = joint_positions_.size();\n\n    // Clear previous tasks\n    hessian_ = Eigen::MatrixXd::Zero(num_dofs, num_dofs);\n    gradient_ = Eigen::VectorXd::Zero(num_dofs);\n\n    // Aggregate tasks based on priority\n    std::map<int, std::vector<Task>> priority_tasks;\n    for (const auto& task : tasks_) {\n        priority_tasks[task.priority].push_back(task);\n    }\n\n    // Process tasks by priority level\n    for (const auto& [priority, level_tasks] : priority_tasks) {\n        for (const auto& task : level_tasks) {\n            // Add task to Hessian: H += J^T * W * J\n            Eigen::MatrixXd weighted_jacobian =\n                task.weight * task.jacobian.transpose() * task.jacobian;\n            hessian_.topLeftCorner(task.jacobian.rows(), num_dofs) += weighted_jacobian;\n\n            // Add task to gradient: g -= J^T * W * desired\n            Eigen::VectorXd task_gradient =\n                -task.weight * task.jacobian.transpose() * task.desired;\n            gradient_.head(task.jacobian.rows()) += task_gradient;\n        }\n    }\n\n    // Add regularization term for numerical stability\n    double regularization = 1e-6;\n    hessian_.diagonal().array() += regularization;\n\n    // Apply joint velocity limits as constraints\n    int num_constraints = 2 * num_dofs; // upper and lower bounds\n    constraint_matrix_ = Eigen::MatrixXd::Zero(num_constraints, num_dofs);\n    constraint_bounds_ = Eigen::VectorXd::Zero(num_constraints);\n\n    for (int i = 0; i < num_dofs; ++i) {\n        // Joint velocity limits (assuming max velocity of 10 rad/s)\n        constraint_matrix_.row(2*i) = Eigen::VectorXd::Unit(num_dofs, i);\n        constraint_bounds_[2*i] = 10.0; // upper bound\n\n        constraint_matrix_.row(2*i + 1) = -Eigen::VectorXd::Unit(num_dofs, i);\n        constraint_bounds_[2*i + 1] = 10.0; // lower bound (negative)\n    }\n}\n\nvoid WholeBodyController::solveQP() {\n    int num_dofs = joint_positions_.size();\n\n    // Convert Eigen matrices to qpOASES format\n    qpOASES::real_t* hessian_data = new qpOASES::real_t[num_dofs * num_dofs];\n    qpOASES::real_t* gradient_data = new qpOASES::real_t[num_dofs];\n    qpOASES::real_t* constraint_data = new qpOASES::real_t[num_dofs * constraint_matrix_.rows()];\n    qpOASES::real_t* bounds_data = new qpOASES::real_t[constraint_matrix_.rows()];\n\n    // Copy data\n    for (int i = 0; i < num_dofs; ++i) {\n        for (int j = 0; j < num_dofs; ++j) {\n            hessian_data[i * num_dofs + j] = hessian_(i, j);\n        }\n        gradient_data[i] = gradient_(i);\n    }\n\n    for (int i = 0; i < constraint_matrix_.rows(); ++i) {\n        for (int j = 0; j < num_dofs; ++j) {\n            constraint_data[i * num_dofs + j] = constraint_matrix_(i, j);\n        }\n        bounds_data[i] = constraint_bounds_[i];\n    }\n\n    // Solve QP problem\n    qpOASES::real_t* solution = new qpOASES::real_t[num_dofs];\n    int nWSR = 100; // maximum number of working set recalculations\n\n    qpOASES::returnValue returnvalue = qp_solver_.init(\n        hessian_data, gradient_data,\n        constraint_data,\n        nullptr, nullptr, // lower/upper bounds on optimization variables (set to infinity)\n        bounds_data,\n        nWSR\n    );\n\n    if (returnvalue == qpOASES::SUCCESSFUL_RETURN) {\n        qp_solver_.getPrimalSolution(solution);\n\n        // Copy solution back to joint velocities\n        for (int i = 0; i < num_dofs; ++i) {\n            joint_velocities_[i] = solution[i];\n        }\n    } else {\n        std::cerr << "QP solver failed with return value: " << returnvalue << std::endl;\n        // Fallback: set to zero velocities\n        joint_velocities_.setZero();\n    }\n\n    // Clean up\n    delete[] hessian_data;\n    delete[] gradient_data;\n    delete[] constraint_data;\n    delete[] bounds_data;\n    delete[] solution;\n}\n\nEigen::VectorXd WholeBodyController::computeControl() {\n    buildOptimizationProblem();\n    solveQP();\n\n    // Clear tasks for next iteration\n    tasks_.clear();\n\n    return joint_velocities_;\n}\n\n// Example usage\nint main() {\n    // Create controller for a 28-DOF humanoid\n    WholeBodyController controller(28);\n\n    // Set initial state\n    Eigen::VectorXd initial_positions = Eigen::VectorXd::Zero(28);\n    Eigen::VectorXd initial_velocities = Eigen::VectorXd::Zero(28);\n    controller.updateState(initial_positions, initial_velocities);\n\n    // Add a reaching task (example)\n    Eigen::MatrixXd reaching_jacobian = Eigen::MatrixXd::Zero(6, 28); // 6-DOF task space\n    Eigen::VectorXd reaching_desired = Eigen::VectorXd::Zero(6);\n    reaching_desired << 0.1, 0.2, 0.0, 0.0, 0.0, 0.0; // desired position/velocity\n\n    Task reaching_task(reaching_jacobian, reaching_desired, 1.0, 1); // priority 1\n    controller.addTask(reaching_task);\n\n    // Add a balance task (example)\n    Eigen::MatrixXd balance_jacobian = Eigen::MatrixXd::Zero(2, 28); // 2-DOF CoM control\n    Eigen::VectorXd balance_desired = Eigen::VectorXd::Zero(2);\n    balance_desired << 0.0, 0.0; // maintain CoM position\n\n    Task balance_task(balance_jacobian, balance_desired, 10.0, 0); // priority 0 (higher)\n    controller.addTask(balance_task);\n\n    // Compute control\n    Eigen::VectorXd control_output = controller.computeControl();\n\n    std::cout << "Computed joint velocities:\\n" << control_output.transpose() << std::endl;\n\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"123-hierarchical-task-prioritization",children:"12.3 Hierarchical Task Prioritization"}),"\n",(0,t.jsx)(e.h3,{id:"1231-priority-based-task-allocation",children:"12.3.1 Priority-Based Task Allocation"}),"\n",(0,t.jsx)(e.p,{children:"Hierarchical control systems organize tasks by importance, ensuring that critical objectives (like maintaining balance) take precedence over secondary goals (like reaching for objects)."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'// HierarchicalTaskManager.h\n#pragma once\n#include <vector>\n#include <memory>\n#include "WholeBodyController.h"\n\nclass HierarchicalTaskManager {\nprivate:\n    std::vector<std::vector<Task>> priority_levels_;\n    WholeBodyController& controller_;\n\npublic:\n    explicit HierarchicalTaskManager(WholeBodyController& controller);\n    void addTask(int priority_level, const Task& task);\n    void clearTasks();\n    Eigen::VectorXd computeHierarchicalControl();\n\nprivate:\n    void processPriorityLevel(int level,\n                            const Eigen::VectorXd& previous_solution = Eigen::VectorXd());\n};\n'})}),"\n",(0,t.jsx)(e.h3,{id:"1232-dynamic-task-reconfiguration",children:"12.3.2 Dynamic Task Reconfiguration"}),"\n",(0,t.jsx)(e.p,{children:"Advanced whole-body controllers can dynamically adjust task priorities based on environmental conditions and robot state."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'// AdaptiveTaskScheduler.cpp\n#include "HierarchicalTaskManager.h"\n\nclass AdaptiveTaskScheduler {\nprivate:\n    HierarchicalTaskManager& task_manager_;\n    double balance_threshold_;\n    double contact_threshold_;\n\npublic:\n    AdaptiveTaskScheduler(HierarchicalTaskManager& tm)\n        : task_manager_(tm), balance_threshold_(0.1), contact_threshold_(50.0) {}\n\n    void updatePriorities(const Eigen::VectorXd& robot_state,\n                        const std::vector<double>& contact_forces) {\n        // Check if robot is in danger of falling\n        double com_deviation = calculateCoMDeviation(robot_state);\n\n        if (com_deviation > balance_threshold_) {\n            // Increase priority of balance tasks\n            adjustTaskPriority("balance", 0); // highest priority\n        }\n\n        // Check for contact forces\n        for (size_t i = 0; i < contact_forces.size(); ++i) {\n            if (contact_forces[i] > contact_threshold_) {\n                // Increase priority of contact maintenance tasks\n                adjustTaskPriority("contact_" + std::to_string(i), 1);\n            }\n        }\n    }\n\nprivate:\n    double calculateCoMDeviation(const Eigen::VectorXd& state) {\n        // Simplified CoM calculation - in practice would use full kinematics\n        return std::abs(state[0]); // Example: x-position deviation\n    }\n\n    void adjustTaskPriority(const std::string& task_name, int new_priority) {\n        // Implementation would search for and reassign task priorities\n    }\n};\n'})}),"\n",(0,t.jsx)(e.h2,{id:"124-real-time-performance-considerations",children:"12.4 Real-Time Performance Considerations"}),"\n",(0,t.jsx)(e.h3,{id:"1241-computational-complexity-analysis",children:"12.4.1 Computational Complexity Analysis"}),"\n",(0,t.jsx)(e.p,{children:"Whole-body control systems must operate within strict real-time constraints. The computational complexity depends on:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Number of optimization variables (degrees of freedom)"}),"\n",(0,t.jsx)(e.li,{children:"Number of constraints (joint limits, contact constraints)"}),"\n",(0,t.jsx)(e.li,{children:"QP solver algorithm and implementation"}),"\n",(0,t.jsx)(e.li,{children:"Task hierarchy depth"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Typical performance requirements for humanoid robots:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Control frequency: 100-1000 Hz"}),"\n",(0,t.jsx)(e.li,{children:"Solution time: < 5 ms for real-time stability"}),"\n",(0,t.jsx)(e.li,{children:"Memory usage: < 100 MB for embedded systems"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"1242-optimization-strategies",children:"12.4.2 Optimization Strategies"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:"// EfficientWholeBodyController.h - Optimized version\n#pragma once\n#include <Eigen/Dense>\n#include <memory>\n\nclass EfficientWholeBodyController {\nprivate:\n    // Pre-allocated matrices to avoid allocation in real-time loop\n    Eigen::MatrixXd hessian_buffer_;\n    Eigen::VectorXd gradient_buffer_;\n    Eigen::MatrixXd constraint_buffer_;\n    Eigen::VectorXd bounds_buffer_;\n\n    // Cached factorizations for faster solving\n    Eigen::LLT<Eigen::MatrixXd> llt_solver_;\n\n    // Sparse matrix representations for large systems\n    Eigen::SparseMatrix<double> sparse_jacobian_;\n\npublic:\n    EfficientWholeBodyController(int num_dofs);\n    Eigen::VectorXd computeControlOptimized();\n\nprivate:\n    void precomputeFactorizations();\n    void solveSparseQP();\n};\n"})}),"\n",(0,t.jsx)(e.h2,{id:"125-integration-with-ros-2-control-framework",children:"12.5 Integration with ROS 2 Control Framework"}),"\n",(0,t.jsx)(e.h3,{id:"1251-ros-2-controller-interface",children:"12.5.1 ROS 2 Controller Interface"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",children:'// whole_body_controller.hpp\n#include <controller_interface/controller_interface.hpp>\n#include <hardware_interface/loaned_command_interface.hpp>\n#include <hardware_interface/loaned_state_interface.hpp>\n#include <rclcpp/rclcpp.hpp>\n#include "WholeBodyController.h"\n\nnamespace whole_body_controller {\n\nclass WholeBodyController : public controller_interface::ControllerInterface {\npublic:\n    WholeBodyController();\n    controller_interface::InterfaceConfiguration command_interface_configuration() const override;\n    controller_interface::InterfaceConfiguration state_interface_configuration() const override;\n    controller_interface::return_type update(\n        const rclcpp::Time& time,\n        const rclcpp::Duration& period) override;\n\nprivate:\n    std::vector<hardware_interface::LoanedCommandInterface> joint_command_interfaces_;\n    std::vector<hardware_interface::LoanedStateInterface> joint_state_interfaces_;\n\n    std::unique_ptr<WholeBodyController> wb_controller_;\n\n    // ROS 2 parameters for whole-body control\n    double control_frequency_;\n    std::vector<std::string> joint_names_;\n\n    // Task publishers/subscribers\n    rclcpp::Subscription<geometry_msgs::msg::Pose>::SharedPtr target_pose_sub_;\n    rclcpp::Publisher<std::vector<double>>::SharedPtr control_output_pub_;\n\n    void targetPoseCallback(const geometry_msgs::msg::Pose::SharedPtr msg);\n};\n\n} // namespace whole_body_controller\n'})}),"\n",(0,t.jsx)(e.h2,{id:"126-practical-considerations-and-limitations",children:"12.6 Practical Considerations and Limitations"}),"\n",(0,t.jsx)(e.h3,{id:"1261-numerical-stability",children:"12.6.1 Numerical Stability"}),"\n",(0,t.jsx)(e.p,{children:"Whole-body control systems must handle numerical instabilities that can arise from:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Poorly conditioned Jacobians"}),"\n",(0,t.jsx)(e.li,{children:"Singular configurations"}),"\n",(0,t.jsx)(e.li,{children:"Ill-posed optimization problems"}),"\n",(0,t.jsx)(e.li,{children:"Floating-point precision errors"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"1262-sensor-integration",children:"12.6.2 Sensor Integration"}),"\n",(0,t.jsx)(e.p,{children:"Real-world whole-body control requires integration with various sensors:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"IMU for orientation and acceleration"}),"\n",(0,t.jsx)(e.li,{children:"Force/torque sensors for contact detection"}),"\n",(0,t.jsx)(e.li,{children:"Joint encoders for position feedback"}),"\n",(0,t.jsx)(e.li,{children:"Vision systems for environment perception"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"Whole-body control represents a sophisticated approach to managing the complex dynamics of humanoid robots by simultaneously optimizing multiple control objectives. The mathematical foundation in quadratic programming enables the integration of multiple tasks with different priorities while respecting physical constraints. Implementation requires careful attention to computational efficiency, numerical stability, and real-time performance requirements. Integration with ROS 2 control frameworks enables deployment on real robotic platforms."}),"\n",(0,t.jsx)(e.p,{children:"The success of whole-body control systems depends on proper task prioritization, constraint handling, and computational optimization. Modern implementations leverage efficient QP solvers and hierarchical optimization techniques to achieve stable control at high frequencies necessary for humanoid robot operation."}),"\n",(0,t.jsx)(e.h2,{id:"review-questions",children:"Review Questions"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Explain the mathematical formulation of whole-body control as a quadratic programming problem. What are the key components of the optimization?"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Describe the hierarchical task prioritization approach in whole-body control. How does it ensure critical tasks take precedence over secondary objectives?"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"What are the computational challenges in implementing whole-body control for humanoid robots? How can these be addressed in real-time systems?"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Compare kinematic vs. dynamic approaches to whole-body control. What are the trade-offs between these methods?"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"How does constraint handling work in whole-body control systems? What types of constraints are typically considered?"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Design a whole-body control system for a humanoid robot performing a reaching task while maintaining balance. Specify the task hierarchy and constraints."}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"What are the key performance requirements for real-time whole-body control? How do these impact the choice of optimization algorithms?"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"Explain how sensor integration affects the performance of whole-body control systems. What types of sensors are critical for different control objectives?"}),"\n"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453(n,e,i){i.d(e,{R:()=>a,x:()=>s});var o=i(6540);const t={},r=o.createContext(t);function a(n){const e=o.useContext(r);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),o.createElement(r.Provider,{value:e},n.children)}}}]);
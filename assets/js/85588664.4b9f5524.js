"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[437],{4864(n,i,e){e.r(i),e.d(i,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"c4-urdf-robot-description","title":"Chapter 4: URDF and Robot Description","description":"Learning Outcomes","source":"@site/chapters/c4-urdf-robot-description.md","sourceDirName":".","slug":"/c4-urdf-robot-description","permalink":"/chapters/c4-urdf-robot-description","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"id":"c4-urdf-robot-description","title":"Chapter 4: URDF and Robot Description","sidebar_label":"C4: URDF","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"C3: Actions & Services","permalink":"/chapters/c3-ros2-actions"},"next":{"title":"C5: Gazebo","permalink":"/chapters/c5-gazebo-simulation"}}');var r=e(4848),t=e(8453);const s={id:"c4-urdf-robot-description",title:"Chapter 4: URDF and Robot Description",sidebar_label:"C4: URDF",sidebar_position:4},l="Chapter 4: URDF and Robot Description",a={},d=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Overview",id:"overview",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"URDF File Structure",id:"urdf-file-structure",level:2},{value:"Joint Types",id:"joint-types",level:3},{value:"Simple Two-Link Robot Example",id:"simple-two-link-robot-example",level:2},{value:"Key Elements Explained",id:"key-elements-explained",level:3},{value:"Visualizing URDF in RViz",id:"visualizing-urdf-in-rviz",level:2},{value:"Launch File for Robot Visualization",id:"launch-file-for-robot-visualization",level:3},{value:"Running the Visualization",id:"running-the-visualization",level:3},{value:"URDF Best Practices for Humanoid Robots",id:"urdf-best-practices-for-humanoid-robots",level:2},{value:"Summary",id:"summary",level:2},{value:"Review Questions",id:"review-questions",level:2}];function c(n){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"chapter-4-urdf-and-robot-description",children:"Chapter 4: URDF and Robot Description"})}),"\n",(0,r.jsx)(i.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,r.jsx)(i.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Create"})," URDF files defining robot links, joints, and hierarchical structures"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Specify"})," visual, collision, and inertial properties for robot components"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Visualize"})," robot models in RViz and understand the robot state publisher workflow"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(i.p,{children:["In Chapters 2-3, we established ROS 2's communication infrastructure\u2014Topics for continuous data, Actions for goal-oriented tasks, and Services for queries. However, humanoid robots require more than communication protocols: they need precise ",(0,r.jsx)(i.strong,{children:"geometric and kinematic models"})," that define their physical structure."]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"URDF (Unified Robot Description Format)"})," is the XML-based standard for describing robot geometry, kinematics, dynamics, and visual appearance in ROS 2. When a humanoid robot plans a walking gait, reaches for an object, or avoids obstacles, it relies on its URDF model to compute joint positions, collision boundaries, and center-of-mass trajectories."]}),"\n",(0,r.jsxs)(i.p,{children:["This chapter introduces URDF's hierarchical structure of ",(0,r.jsx)(i.strong,{children:"Links"})," (rigid bodies) and ",(0,r.jsx)(i.strong,{children:"Joints"})," (connections between links). You will create URDF files, specify physical properties for simulation, and visualize robot models in RViz. This knowledge forms the foundation for the kinematics, dynamics, and simulation covered in subsequent modules."]}),"\n",(0,r.jsx)(i.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"URDF (Unified Robot Description Format)"}),": XML-based file format for describing robot mechanical structure, including links, joints, geometry, and physical properties"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Link"}),": Rigid body component of a robot (e.g., torso, upper arm, thigh) with visual, collision, and inertial properties"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Joint"}),": Connection between two links defining their relative motion (revolute, prismatic, continuous, fixed, planar, floating)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Visual"}),": Geometric representation of a link for rendering and visualization (cylinders, boxes, meshes)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Collision"}),": Simplified geometry used for collision detection during motion planning and simulation"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Inertial"}),": Physical properties of a link including mass and inertia tensor required for dynamics simulation"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Robot State Publisher"}),": ROS 2 node that reads URDF and publishes TF transforms for all robot links"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"RViz"}),": 3D visualization tool for viewing robot models, sensor data, and planning results"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"urdf-file-structure",children:"URDF File Structure"}),"\n",(0,r.jsxs)(i.p,{children:["A URDF file is an XML document with a ",(0,r.jsx)(i.code,{children:"<robot>"})," root element containing ",(0,r.jsx)(i.code,{children:"<link>"})," and ",(0,r.jsx)(i.code,{children:"<joint>"})," definitions:"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="robot_name">\n  \x3c!-- Material definitions (optional) --\x3e\n  <material name="blue">\n    <color rgba="0 0 0.8 1"/>\n  </material>\n\n  \x3c!-- Link definitions --\x3e\n  <link name="base_link">\n    <visual>...</visual>\n    <collision>...</collision>\n    <inertial>...</inertial>\n  </link>\n\n  \x3c!-- Joint definitions --\x3e\n  <joint name="joint_name" type="revolute">\n    <parent link="base_link"/>\n    <child link="link2"/>\n    <origin xyz="0 0 0.5" rpy="0 0 0"/>\n    <axis xyz="0 0 1"/>\n    <limit lower="-1.57" upper="1.57" effort="10" velocity="1.0"/>\n  </joint>\n</robot>\n'})}),"\n",(0,r.jsx)(i.h3,{id:"joint-types",children:"Joint Types"}),"\n",(0,r.jsxs)(i.table,{children:[(0,r.jsx)(i.thead,{children:(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.th,{children:"Type"}),(0,r.jsx)(i.th,{children:"Description"}),(0,r.jsx)(i.th,{children:"Degrees of Freedom"}),(0,r.jsx)(i.th,{children:"Use Case"})]})}),(0,r.jsxs)(i.tbody,{children:[(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.strong,{children:"revolute"})}),(0,r.jsx)(i.td,{children:"Hinge joint with angle limits"}),(0,r.jsx)(i.td,{children:"1 (rotation)"}),(0,r.jsx)(i.td,{children:"Robot arm joints, knee, elbow"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.strong,{children:"continuous"})}),(0,r.jsx)(i.td,{children:"Hinge joint without limits"}),(0,r.jsx)(i.td,{children:"1 (rotation)"}),(0,r.jsx)(i.td,{children:"Wheels, continuous rotation joints"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.strong,{children:"prismatic"})}),(0,r.jsx)(i.td,{children:"Sliding joint"}),(0,r.jsx)(i.td,{children:"1 (translation)"}),(0,r.jsx)(i.td,{children:"Linear actuators, telescoping links"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.strong,{children:"fixed"})}),(0,r.jsx)(i.td,{children:"No relative motion"}),(0,r.jsx)(i.td,{children:"0"}),(0,r.jsx)(i.td,{children:"Sensor mounts, structural connections"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.strong,{children:"planar"})}),(0,r.jsx)(i.td,{children:"Motion in a plane"}),(0,r.jsx)(i.td,{children:"2 (translation in XY)"}),(0,r.jsx)(i.td,{children:"Mobile base constraints"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.strong,{children:"floating"})}),(0,r.jsx)(i.td,{children:"Unconstrained motion"}),(0,r.jsx)(i.td,{children:"6 (3 translation + 3 rotation)"}),(0,r.jsx)(i.td,{children:"Free-floating base (humanoid torso)"})]})]})]}),"\n",(0,r.jsx)(i.h2,{id:"simple-two-link-robot-example",children:"Simple Two-Link Robot Example"}),"\n",(0,r.jsx)(i.p,{children:"This URDF defines a simple 2-link robot arm with a revolute joint:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_arm">\n\n  \x3c!-- Material definitions --\x3e\n  <material name="blue">\n    <color rgba="0 0 0.8 1"/>\n  </material>\n\n  <material name="white">\n    <color rgba="1 1 1 1"/>\n  </material>\n\n  \x3c!-- Base link (fixed to world) --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <cylinder length="0.1" radius="0.05"/>\n      </geometry>\n      <material name="blue"/>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="0.1" radius="0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="0.5"/>\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0"\n               iyy="0.001" iyz="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Upper arm link --\x3e\n  <link name="upper_arm">\n    <visual>\n      <geometry>\n        <box size="0.05 0.05 0.3"/>\n      </geometry>\n      <origin xyz="0 0 0.15" rpy="0 0 0"/>\n      <material name="white"/>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.05 0.05 0.3"/>\n      </geometry>\n      <origin xyz="0 0 0.15" rpy="0 0 0"/>\n    </collision>\n    <inertial>\n      <mass value="0.3"/>\n      <origin xyz="0 0 0.15" rpy="0 0 0"/>\n      <inertia ixx="0.002" ixy="0.0" ixz="0.0"\n               iyy="0.002" iyz="0.0" izz="0.0001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Shoulder joint (revolute) --\x3e\n  <joint name="shoulder_joint" type="revolute">\n    <parent link="base_link"/>\n    <child link="upper_arm"/>\n    <origin xyz="0 0 0.05" rpy="0 0 0"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-1.57" upper="1.57" effort="10.0" velocity="1.0"/>\n  </joint>\n\n</robot>\n'})}),"\n",(0,r.jsx)(i.h3,{id:"key-elements-explained",children:"Key Elements Explained"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:(0,r.jsx)(i.code,{children:'<origin xyz="x y z" rpy="roll pitch yaw"/>'})}),": Position and orientation of link/joint relative to parent frame"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:(0,r.jsx)(i.code,{children:'<axis xyz="x y z"/>'})}),": Rotation axis for revolute/continuous joints or translation direction for prismatic joints"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:(0,r.jsx)(i.code,{children:"<limit>"})}),": Joint constraints - ",(0,r.jsx)(i.code,{children:"lower"}),"/",(0,r.jsx)(i.code,{children:"upper"})," (radians or meters), ",(0,r.jsx)(i.code,{children:"effort"})," (torque/force in N\u22c5m or N), ",(0,r.jsx)(i.code,{children:"velocity"})," (rad/s or m/s)"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:(0,r.jsx)(i.code,{children:"<inertia>"})}),": 3\xd73 inertia tensor - ",(0,r.jsx)(i.code,{children:"ixx"}),", ",(0,r.jsx)(i.code,{children:"iyy"}),", ",(0,r.jsx)(i.code,{children:"izz"})," (diagonal), ",(0,r.jsx)(i.code,{children:"ixy"}),", ",(0,r.jsx)(i.code,{children:"ixz"}),", ",(0,r.jsx)(i.code,{children:"iyz"})," (off-diagonal). Units: kg\u22c5m\xb2"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"visualizing-urdf-in-rviz",children:"Visualizing URDF in RViz"}),"\n",(0,r.jsx)(i.h3,{id:"launch-file-for-robot-visualization",children:"Launch File for Robot Visualization"}),"\n",(0,r.jsx)(i.p,{children:"This Python launch file loads a URDF, starts the robot state publisher, and launches RViz:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-python",children:"# display_robot.launch.py\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration, Command\nfrom launch_ros.parameter_descriptions import ParameterValue\nimport os\nfrom ament_index_python.packages import get_package_share_directory\n\ndef generate_launch_description():\n    # Path to URDF file\n    urdf_file = os.path.join(\n        get_package_share_directory('my_robot_description'),\n        'urdf',\n        'simple_arm.urdf'\n    )\n\n    # Read URDF content\n    robot_description = ParameterValue(\n        Command(['cat ', urdf_file]),\n        value_type=str\n    )\n\n    # Robot State Publisher node\n    robot_state_publisher = Node(\n        package='robot_state_publisher',\n        executable='robot_state_publisher',\n        parameters=[{'robot_description': robot_description}]\n    )\n\n    # Joint State Publisher GUI (for manual control)\n    joint_state_publisher_gui = Node(\n        package='joint_state_publisher_gui',\n        executable='joint_state_publisher_gui'\n    )\n\n    # RViz node\n    rviz_node = Node(\n        package='rviz2',\n        executable='rviz2',\n        arguments=['-d', os.path.join(\n            get_package_share_directory('my_robot_description'),\n            'rviz',\n            'view_robot.rviz'\n        )]\n    )\n\n    return LaunchDescription([\n        robot_state_publisher,\n        joint_state_publisher_gui,\n        rviz_node\n    ])\n"})}),"\n",(0,r.jsx)(i.h3,{id:"running-the-visualization",children:"Running the Visualization"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:"# Build the package\ncolcon build --packages-select my_robot_description\n\n# Source the workspace\nsource install/setup.bash\n\n# Launch RViz with robot model\nros2 launch my_robot_description display_robot.launch.py\n"})}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(i.strong,{children:"Robot State Publisher"})," reads the URDF and publishes TF (transform) messages for each link. The ",(0,r.jsx)(i.strong,{children:"Joint State Publisher GUI"})," provides sliders to manually control joint angles. ",(0,r.jsx)(i.strong,{children:"RViz"})," subscribes to TF and renders the robot model in 3D."]}),"\n",(0,r.jsx)(i.h2,{id:"urdf-best-practices-for-humanoid-robots",children:"URDF Best Practices for Humanoid Robots"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Use meters, kilograms, radians"}),": URDF follows SI units. Joint limits in radians, masses in kg, lengths in m"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Provide realistic inertia values"}),": Incorrect inertia causes simulation instability. Use CAD tools or online calculators"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Separate visual and collision geometry"}),": Visual can be high-detail meshes; collision should be simplified primitives for performance"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Define materials for visualization"}),": Use ",(0,r.jsx)(i.code,{children:"<material>"})," tags with RGBA colors for better RViz rendering"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Follow kinematic chain convention"}),": Base link \u2192 torso \u2192 limbs. Parent links defined before child links"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Test in RViz before simulation"}),": Verify link positions, joint axes, and limits before moving to Gazebo"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(i.p,{children:["URDF provides the geometric and kinematic foundation for ROS 2 robot systems. By defining ",(0,r.jsx)(i.strong,{children:"Links"})," (rigid bodies with visual, collision, and inertial properties) and ",(0,r.jsx)(i.strong,{children:"Joints"})," (connections with motion constraints), URDF enables motion planning, dynamics simulation, and visualization. The ",(0,r.jsx)(i.strong,{children:"Robot State Publisher"})," and ",(0,r.jsx)(i.strong,{children:"RViz"})," workflow allows real-time visualization of robot configurations."]}),"\n",(0,r.jsx)(i.p,{children:"In Module 2, we will extend URDF models into simulation environments (Gazebo, Isaac Sim) where collision geometry and inertial properties enable physics-based interaction with virtual worlds. Understanding URDF structure is essential for these advanced applications."}),"\n",(0,r.jsx)(i.h2,{id:"review-questions",children:"Review Questions"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Conceptual"}),": Why do humanoid robots require separate visual and collision geometries in their URDF definitions?"]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Applied"}),": Modify the ",(0,r.jsx)(i.code,{children:"simple_arm"})," URDF to add a forearm link connected by an elbow joint. What joint type should the elbow use?"]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Structural"}),": What are the three required child elements of a ",(0,r.jsx)(i.code,{children:"<link>"})," tag for physics simulation, and what does each specify?"]}),"\n"]}),"\n"]})]})}function h(n={}){const{wrapper:i}={...(0,t.R)(),...n.components};return i?(0,r.jsx)(i,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},8453(n,i,e){e.d(i,{R:()=>s,x:()=>l});var o=e(6540);const r={},t=o.createContext(r);function s(n){const i=o.useContext(t);return o.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function l(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:s(n.components),o.createElement(t.Provider,{value:i},n.children)}}}]);
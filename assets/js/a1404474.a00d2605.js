"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[424],{5236(n,t,i){i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>e,toc:()=>c});const e=JSON.parse('{"id":"c7-unity-simulation","title":"Chapter 7: Unity Simulation for Humanoid Robotics","description":"Learning Outcomes","source":"@site/chapters/c7-unity-simulation.md","sourceDirName":".","slug":"/c7-unity-simulation","permalink":"/chapters/c7-unity-simulation","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"id":"c7-unity-simulation","title":"Chapter 7: Unity Simulation for Humanoid Robotics","sidebar_label":"C7: Unity Simulation","sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"C6: Isaac Sim","permalink":"/chapters/c6-isaac-sim"},"next":{"title":"C8: Advanced Simulation","permalink":"/chapters/c8-advanced-simulation"}}');var o=i(4848),a=i(8453);const s={id:"c7-unity-simulation",title:"Chapter 7: Unity Simulation for Humanoid Robotics",sidebar_label:"C7: Unity Simulation",sidebar_position:7},r="Chapter 7: Unity Simulation for Humanoid Robotics",l={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Overview",id:"overview",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Unity Robotics Architecture and ECS",id:"unity-robotics-architecture-and-ecs",level:2},{value:"ECS-Based Robot Representation",id:"ecs-based-robot-representation",level:3},{value:"ECS System for Physics Simulation",id:"ecs-system-for-physics-simulation",level:3},{value:"URDF Import and Robot Model Integration",id:"urdf-import-and-robot-model-integration",level:2},{value:"URDF Loader Implementation",id:"urdf-loader-implementation",level:3},{value:"Physics Simulation Configuration",id:"physics-simulation-configuration",level:2},{value:"Physics World Setup",id:"physics-world-setup",level:3},{value:"Contact Detection and Balance Control",id:"contact-detection-and-balance-control",level:3},{value:"Unity-Based Humanoid Control Systems",id:"unity-based-humanoid-control-systems",level:2},{value:"Inverse Kinematics System",id:"inverse-kinematics-system",level:3},{value:"Visualization and Debugging Tools",id:"visualization-and-debugging-tools",level:2},{value:"Summary",id:"summary",level:2},{value:"Review Questions",id:"review-questions",level:2}];function u(n){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"chapter-7-unity-simulation-for-humanoid-robotics",children:"Chapter 7: Unity Simulation for Humanoid Robotics"})}),"\n",(0,o.jsx)(t.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,o.jsx)(t.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Configure"})," Unity environments for humanoid robot simulation with physics and rendering optimization"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Import"})," URDF robot models into Unity using specialized loaders and maintain kinematic accuracy"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Implement"})," humanoid control systems using Unity's physics engine and ECS (Entity Component System)"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Deploy"})," Unity simulations for rapid prototyping and visualization of humanoid behaviors"]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(t.p,{children:"Chapter 5 introduced Gazebo simulation with physics-based dynamics and Chapter 6 explored NVIDIA Isaac Sim's GPU-accelerated photorealistic rendering. While these platforms excel at physics accuracy and synthetic data generation respectively, humanoid robotics development also benefits from game engine-based simulation for rapid prototyping, visualization, and interactive development."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Unity"})," provides a powerful real-time 3D development platform that combines high-performance physics simulation with sophisticated rendering capabilities, intuitive visual editing tools, and extensive asset libraries. Unity's flexible Entity Component System (ECS) architecture and Data-Oriented Technology Stack (DOTS) make it particularly suitable for simulating complex humanoid systems with multiple interacting components."]}),"\n",(0,o.jsx)(t.p,{children:"This chapter introduces Unity's robotics capabilities, URDF import workflows, physics simulation using Unity Physics, and ECS-based control systems. You will learn to configure Unity environments for humanoid simulation, import and maintain robot models, and implement control systems that leverage Unity's real-time capabilities for interactive development and testing."}),"\n",(0,o.jsx)(t.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Unity"}),": Cross-platform real-time 3D development platform for creating interactive applications, games, and simulations"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"URDF Loaders"}),": Tools and packages that enable importing Robot Operating System (ROS) URDF files into Unity for robot model representation"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Entity Component System (ECS)"}),": Unity's data-oriented architecture pattern that separates data (components) from behavior (systems) for high-performance simulation"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Unity Physics"}),": High-performance physics engine providing constrained rigid body simulation for Unity projects"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Data-Oriented Technology Stack (DOTS)"}),": Unity's collection of technologies (ECS, Burst Compiler, Unity Collections) for building high-performance applications"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Burst Compiler"}),": Unity compiler that generates highly optimized native code from C# for significant performance gains"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"PhysicsWorld"}),": Unity Physics data structure containing all physics simulation state including rigid bodies, colliders, and constraints"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"SimulationSingleton"}),": Unity Physics component that manages the physics simulation pipeline and step execution"]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"unity-robotics-architecture-and-ecs",children:"Unity Robotics Architecture and ECS"}),"\n",(0,o.jsx)(t.p,{children:"Unity's architecture for robotics leverages the Entity Component System (ECS) pattern for high-performance simulation:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  ROS 2 Bridge   \u2502\u25c4\u2500\u2500\u25ba\u2502  Unity Robotics  \u2502\u25c4\u2500\u2500\u25ba\u2502  Unity Physics   \u2502\n\u2502  (Controllers,  \u2502    \u2502  Package         \u2502    \u2502  (PhysicsWorld,  \u2502\n\u2502   Perception)   \u2502    \u2502                  \u2502    \u2502   Constraints)   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                      \u2502\n                                                      \u25bc\n                                               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                               \u2502  ECS Architecture\u2502\n                                               \u2502  (Entities,      \u2502\n                                               \u2502   Components,     \u2502\n                                               \u2502   Systems)        \u2502\n                                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                      \u2502\n                                                      \u25bc\n                                               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                               \u2502  Burst Compiler  \u2502\n                                               \u2502  (Native Code    \u2502\n                                               \u2502   Optimization)  \u2502\n                                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Unity's ECS architecture separates data (Components) from behavior (Systems), enabling efficient parallel processing and memory layout optimization. The ",(0,o.jsx)(t.strong,{children:"Burst Compiler"})," transforms C# code into highly optimized native code that runs at near-C++ performance."]}),"\n",(0,o.jsx)(t.h3,{id:"ecs-based-robot-representation",children:"ECS-Based Robot Representation"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"// RobotComponents.cs - Unity ECS Components for Robot Representation\nusing Unity.Entities;\nusing Unity.Mathematics;\nusing Unity.Physics;\n\n// Robot identification and state\npublic struct RobotIdentity : IComponentData\n{\n    public FixedString64Bytes RobotName;\n    public int RobotId;\n}\n\npublic struct RobotState : IComponentData\n{\n    public float3 Position;\n    public quaternion Rotation;\n    public float3 Velocity;\n    public float3 AngularVelocity;\n}\n\n// Joint state component\npublic struct JointState : IComponentData\n{\n    public float Position;\n    public float Velocity;\n    public float Effort;\n    public float MinPosition;\n    public float MaxPosition;\n}\n\n// URDF link mapping\npublic struct URDFLink : IComponentData\n{\n    public FixedString64Bytes LinkName;\n    public float Mass;\n    public float3 CenterOfMass;\n    public float3 InertiaTensor;\n}\n\n// Physics configuration\npublic struct PhysicsConfig : IComponentData\n{\n    public float GravityScale;\n    public bool IsKinematic;\n    public PhysicsMaterial Material;\n}\n"})}),"\n",(0,o.jsx)(t.h3,{id:"ecs-system-for-physics-simulation",children:"ECS System for Physics Simulation"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"// RobotPhysicsSystem.cs - Unity ECS System for Robot Physics\nusing Unity.Burst;\nusing Unity.Entities;\nusing Unity.Physics;\nusing Unity.Physics.Systems;\nusing Unity.Mathematics;\n\n[BurstCompile]\npublic partial struct RobotPhysicsSystem : ISystem\n{\n    private SimulationSystemGroup simulationSystemGroup;\n\n    [BurstCompile]\n    public void OnCreate(ref SystemState state)\n    {\n        simulationSystemGroup = state.World.GetOrCreateSystem<SimulationSystemGroup>();\n    }\n\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        // Get physics world singleton for read-write access\n        var physicsWorld = SystemAPI.GetSingletonRW<PhysicsWorldSingleton>();\n        var simulation = simulationSystemGroup.CreateSimulation(ref state);\n\n        // Process all robot entities with physics components\n        var robotEntityGroup = SystemAPI.QueryBuilder()\n            .WithAll<RobotIdentity, RobotState, PhysicsBody>()\n            .Build();\n\n        var robotEntities = robotEntityGroup.ToEntityArray(Allocator.Temp);\n        var robotStates = robotEntityGroup.ToComponentDataArray<RobotState>(Allocator.Temp);\n\n        // Update robot physics based on control inputs\n        foreach (var entity in robotEntities)\n        {\n            if (state.EntityManager.HasComponent<JointControl>(entity))\n            {\n                var jointControl = state.EntityManager.GetComponentData<JointControl>(entity);\n                var robotState = state.EntityManager.GetComponentData<RobotState>(entity);\n\n                // Apply joint forces based on control inputs\n                ApplyJointForces(ref state, entity, jointControl, robotState);\n            }\n        }\n\n        robotEntities.Dispose();\n        robotStates.Dispose();\n    }\n\n    private void ApplyJointForces(ref SystemState state, Entity robotEntity,\n                                 JointControl control, RobotState robotState)\n    {\n        // Implementation for applying physics forces to robot joints\n        // This would typically involve calculating torques based on desired positions\n        // and current positions, then applying those forces to the physics simulation\n    }\n}\n\n// Component for joint control commands\npublic struct JointControl : IComponentData\n{\n    public DynamicBuffer<JointCommand> Commands;\n}\n\npublic struct JointCommand : IBufferElementData\n{\n    public int JointIndex;\n    public float TargetPosition;\n    public float TargetVelocity;\n    public float MaxEffort;\n}\n"})}),"\n",(0,o.jsx)(t.h2,{id:"urdf-import-and-robot-model-integration",children:"URDF Import and Robot Model Integration"}),"\n",(0,o.jsx)(t.p,{children:"Unity supports importing URDF robot models through specialized loader packages that maintain kinematic accuracy and visual representation:"}),"\n",(0,o.jsx)(t.h3,{id:"urdf-loader-implementation",children:"URDF Loader Implementation"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:'// URDFLoader.cs - Loading URDF Models into Unity\nusing System.Collections.Generic;\nusing UnityEngine;\nusing Unity.Entities;\nusing Unity.Mathematics;\n\npublic class URDFLoader : MonoBehaviour\n{\n    [System.Serializable]\n    public struct URDFLoaderOptions\n    {\n        public System.Action<string, string, System.Action<GameObject[]>> LoadMeshCb;\n        public URDFRobot TargetRobot;\n        public string WorkingPath;\n    }\n\n    public URDFRobot Load(string urdfPath, string packagePath, URDFLoaderOptions options = new URDFLoaderOptions())\n    {\n        // Read and process the URDF file at the given path\n        string urdfContent = System.IO.File.ReadAllText(urdfPath);\n        return Parse(urdfContent, packagePath, options);\n    }\n\n    public URDFRobot Parse(string urdfContent, string packagePath, URDFLoaderOptions options = new URDFLoaderOptions())\n    {\n        // Parse URDF XML content and create Unity GameObject hierarchy\n        URDFRobot robot = options.TargetRobot ?? new URDFRobot();\n\n        // Process robot name from URDF\n        robot.robotName = ExtractRobotName(urdfContent);\n\n        // Parse links and joints from URDF\n        var links = ParseLinks(urdfContent);\n        var joints = ParseJoints(urdfContent);\n\n        // Create Unity GameObject hierarchy\n        foreach (var link in links)\n        {\n            CreateLinkGameObject(robot, link, options);\n        }\n\n        foreach (var joint in joints)\n        {\n            CreateJointConstraint(robot, joint, options);\n        }\n\n        return robot;\n    }\n\n    private void CreateLinkGameObject(URDFRobot robot, URDFLinkData linkData, URDFLoaderOptions options)\n    {\n        GameObject linkObject = new GameObject(linkData.Name);\n\n        // Set transform based on URDF origin\n        linkObject.transform.position = URDFToUnityPosition(linkData.Origin.Position);\n        linkObject.transform.rotation = URDFToUnityRotation(linkData.Origin.Rotation);\n\n        // Add physics components based on URDF inertial and visual data\n        if (linkData.Inertial != null)\n        {\n            var rb = linkObject.AddComponent<Rigidbody>();\n            rb.mass = linkData.Inertial.Mass;\n            rb.centerOfMass = URDFToUnityPosition(linkData.Inertial.Origin.Position);\n\n            // Set inertia tensor\n            rb.inertiaTensor = URDFToUnityVector(linkData.Inertial.Inertia);\n        }\n\n        // Add visual mesh if present\n        if (linkData.Visual != null && linkData.Visual.Geometry != null)\n        {\n            AddVisualMesh(linkObject, linkData.Visual, options);\n        }\n\n        // Add collision mesh if present\n        if (linkData.Collision != null && linkData.Collision.Geometry != null)\n        {\n            AddCollisionMesh(linkObject, linkData.Collision, options);\n        }\n\n        robot.Links.Add(linkData.Name, linkObject);\n    }\n\n    private void AddVisualMesh(GameObject linkObject, URDFVisual visual, URDFLoaderOptions options)\n    {\n        // Load visual geometry based on URDF specification\n        if (visual.Geometry.Mesh != null)\n        {\n            string meshPath = ResolvePackagePath(visual.Geometry.Mesh.Filename, options.WorkingPath);\n            if (options.LoadMeshCb != null)\n            {\n                options.LoadMeshCb(meshPath, System.IO.Path.GetExtension(meshPath),\n                    (gameObjects) => {\n                        foreach (var go in gameObjects)\n                        {\n                            go.transform.SetParent(linkObject.transform);\n                            go.AddComponent<MeshRenderer>();\n                        }\n                    });\n            }\n        }\n    }\n\n    private void AddCollisionMesh(GameObject linkObject, URDFCollision collision, URDFLoaderOptions options)\n    {\n        // Add collision components based on URDF specification\n        if (collision.Geometry.Mesh != null)\n        {\n            string meshPath = ResolvePackagePath(collision.Geometry.Mesh.Filename, options.WorkingPath);\n            var meshCollider = linkObject.AddComponent<MeshCollider>();\n            // Load and assign collision mesh\n        }\n        else if (collision.Geometry.Box != null)\n        {\n            var boxCollider = linkObject.AddComponent<BoxCollider>();\n            boxCollider.size = URDFToUnityVector(collision.Geometry.Box.Size);\n        }\n        else if (collision.Geometry.Cylinder != null)\n        {\n            var capsuleCollider = linkObject.AddComponent<CapsuleCollider>();\n            capsuleCollider.radius = collision.Geometry.Cylinder.Radius;\n            capsuleCollider.height = collision.Geometry.Cylinder.Length;\n        }\n        else if (collision.Geometry.Sphere != null)\n        {\n            var sphereCollider = linkObject.AddComponent<SphereCollider>();\n            sphereCollider.radius = collision.Geometry.Sphere.Radius;\n        }\n    }\n\n    // Helper methods for coordinate system conversion\n    private Vector3 URDFToUnityPosition(URDFVector3 urdfPos)\n    {\n        // URDF uses right-handed coordinate system (X forward, Y left, Z up)\n        // Unity uses left-handed coordinate system (X right, Y up, Z forward)\n        return new Vector3(urdfPos.Y, urdfPos.Z, urdfPos.X);\n    }\n\n    private Quaternion URDFToUnityRotation(URDFVector3 urdfRot)\n    {\n        // Convert URDF Euler angles to Unity quaternion\n        Vector3 unityEuler = URDFToUnityPosition(urdfRot);\n        return Quaternion.Euler(unityEuler);\n    }\n\n    private Vector3 URDFToUnityVector(URDFVector3 urdfVec)\n    {\n        return new Vector3(urdfVec.Y, urdfVec.Z, urdfVec.X);\n    }\n\n    private string ResolvePackagePath(string filename, string workingPath)\n    {\n        if (filename.StartsWith("package://"))\n        {\n            // Replace package:// with working path\n            return filename.Replace("package://", workingPath + "/");\n        }\n        return filename;\n    }\n}\n\n// URDF Data Structures\n[System.Serializable]\npublic class URDFRobot\n{\n    public string robotName;\n    public Dictionary<string, GameObject> Links = new Dictionary<string, GameObject>();\n    public Dictionary<string, Joint> Joints = new Dictionary<string, Joint>();\n    public Dictionary<string, GameObject> Colliders = new Dictionary<string, GameObject>();\n    public Dictionary<string, GameObject> Visuals = new Dictionary<string, GameObject>();\n    public Dictionary<string, Transform> Frames = new Dictionary<string, Transform>();\n}\n\n[System.Serializable]\npublic struct URDFLinkData\n{\n    public string Name;\n    public URDFInertial Inertial;\n    public URDFVisual Visual;\n    public URDFCollision Collision;\n    public URDFOrigin Origin;\n}\n\n[System.Serializable]\npublic struct URDFJointData\n{\n    public string Name;\n    public string Type;\n    public string ParentLink;\n    public string ChildLink;\n    public URDFOrigin Origin;\n    public URDFAxis Axis;\n    public URDFJointLimit Limit;\n}\n\n[System.Serializable]\npublic struct URDFVector3\n{\n    public float X, Y, Z;\n}\n'})}),"\n",(0,o.jsx)(t.h2,{id:"physics-simulation-configuration",children:"Physics Simulation Configuration"}),"\n",(0,o.jsx)(t.p,{children:"Unity's physics engine provides high-performance simulation capabilities for humanoid robots:"}),"\n",(0,o.jsx)(t.h3,{id:"physics-world-setup",children:"Physics World Setup"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"// PhysicsSetup.cs - Configuring Physics for Humanoid Simulation\nusing Unity.Entities;\nusing Unity.Physics;\nusing Unity.Physics.Systems;\nusing UnityEngine;\n\npublic class PhysicsSetup : MonoBehaviour\n{\n    public float Gravity = -9.81f;\n    public float FixedTimeStep = 0.016666f; // 60 Hz\n    public int SolverIterations = 8;\n    public PhysicsMaterial DefaultMaterial;\n\n    void Start()\n    {\n        // Configure physics settings\n        Physics.simulationMode = SimulationMode.Script;\n        Physics.defaultSolverIterations = SolverIterations;\n\n        // Set gravity (Unity uses Y as up, so gravity is negative Y)\n        Physics.gravity = new Vector3(0, Gravity, 0);\n\n        // Initialize physics world through ECS\n        InitializePhysicsWorld();\n    }\n\n    private void InitializePhysicsWorld()\n    {\n        var entityManager = World.DefaultGameObjectInjectionWorld.EntityManager;\n\n        // Create physics world singleton if it doesn't exist\n        var physicsWorldEntity = entityManager.CreateEntity();\n        entityManager.AddComponentData(physicsWorldEntity, new PhysicsWorldSingleton());\n\n        // Configure simulation parameters\n        var simulationEntity = entityManager.CreateEntity();\n        entityManager.AddComponentData(simulationEntity, new SimulationSingleton());\n    }\n}\n\n// PhysicsSystemGroup configuration for humanoid robots\n[UpdateInGroup(typeof(FixedStepSimulationSystemGroup))]\n[UpdateBefore(typeof(ExportPhysicsWorld))]\npublic partial struct HumanoidPhysicsSystemGroup : ISystem\n{\n    public void OnCreate(ref SystemState state)\n    {\n        // Configure the simulation group for humanoid physics\n        state.RequireForUpdate<SimulationSingleton>();\n    }\n\n    public void OnUpdate(ref SystemState state)\n    {\n        // Custom physics update logic for humanoid robots\n        // This could include special handling for balance, contact detection, etc.\n    }\n}\n"})}),"\n",(0,o.jsx)(t.h3,{id:"contact-detection-and-balance-control",children:"Contact Detection and Balance Control"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"// BalanceControlSystem.cs - ECS System for Humanoid Balance Control\nusing Unity.Burst;\nusing Unity.Entities;\nusing Unity.Physics;\nusing Unity.Physics.Systems;\nusing Unity.Mathematics;\n\n[BurstCompile]\npublic partial struct BalanceControlSystem : ISystem\n{\n    private BuildPhysicsWorld buildPhysicsWorldSystem;\n    private SimulationSystemGroup simulationSystemGroup;\n\n    [BurstCompile]\n    public void OnCreate(ref SystemState state)\n    {\n        buildPhysicsWorldSystem = state.World.GetOrCreateSystem<BuildPhysicsWorld>();\n        simulationSystemGroup = state.World.GetOrCreateSystem<SimulationSystemGroup>();\n    }\n\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        // Get physics world for contact detection\n        var physicsWorld = SystemAPI.GetSingletonRW<PhysicsWorldSingleton>();\n\n        // Query for humanoid entities that need balance control\n        var humanoidQuery = SystemAPI.QueryBuilder()\n            .WithAll<HumanoidTag, BalanceController, RobotState>()\n            .Build();\n\n        var humanoidEntities = humanoidQuery.ToEntityArray(Allocator.Temp);\n\n        foreach (var entity in humanoidEntities)\n        {\n            // Perform balance control calculations\n            var balanceController = state.EntityManager.GetComponentData<BalanceController>(entity);\n            var robotState = state.EntityManager.GetComponentData<RobotState>(entity);\n\n            // Detect ground contact for balance\n            var groundContacts = DetectGroundContacts(ref physicsWorld.ValueRO, entity);\n\n            // Apply balance corrections\n            ApplyBalanceControl(ref state, entity, balanceController, robotState, groundContacts);\n        }\n\n        humanoidEntities.Dispose();\n    }\n\n    private NativeArray<DistanceHit> DetectGroundContacts(\n        ref PhysicsWorldSingleton physicsWorld, Entity humanoidEntity)\n    {\n        // Perform raycasts to detect ground contact\n        var entityManager = SystemAPI.GetEntityManagerRW();\n        var humanoidState = entityManager.GetComponentData<RobotState>(humanoidEntity);\n\n        // Cast rays from feet to ground\n        var raycastInput = new RaycastInput\n        {\n            Start = humanoidState.Position + new float3(0, -0.1f, 0), // Slightly below feet\n            End = humanoidState.Position + new float3(0, -0.5f, 0),   // Down to ground\n            Filter = CollisionFilter.Default\n        };\n\n        var hits = new NativeList<DistanceHit>(64, Allocator.Temp);\n        physicsWorld.CastRay(raycastInput, hits);\n\n        return hits.AsArray();\n    }\n\n    private void ApplyBalanceControl(ref SystemState state, Entity entity,\n                                   BalanceController controller, RobotState robotState,\n                                   NativeArray<DistanceHit> contacts)\n    {\n        // Calculate balance corrections based on contact points\n        float3 centerOfMass = CalculateCenterOfMass(state.EntityManager, entity);\n        float3 centerOfPressure = CalculateCenterOfPressure(contacts);\n\n        // Simple inverted pendulum model for balance\n        float3 error = centerOfMass.xz - centerOfPressure.xz;\n        float3 correction = error * controller.PGain;\n\n        // Apply correction torques to joints\n        ApplyTorquesToJoints(ref state, entity, correction, controller);\n    }\n\n    private float3 CalculateCenterOfMass(EntityManager entityManager, Entity entity)\n    {\n        // Calculate center of mass based on all rigid bodies in the humanoid\n        // Implementation would aggregate masses and positions of all links\n        return new float3(0, 0, 0);\n    }\n\n    private float3 CalculateCenterOfPressure(NativeArray<DistanceHit> contacts)\n    {\n        // Calculate center of pressure from contact points\n        if (contacts.Length == 0) return new float3(0, 0, 0);\n\n        float3 cop = new float3(0, 0, 0);\n        float totalForce = 0;\n\n        for (int i = 0; i < contacts.Length; i++)\n        {\n            cop += contacts[i].Position * contacts[i].Distance;\n            totalForce += contacts[i].Distance;\n        }\n\n        return totalForce > 0 ? cop / totalForce : new float3(0, 0, 0);\n    }\n\n    private void ApplyTorquesToJoints(ref SystemState state, Entity entity,\n                                    float3 correction, BalanceController controller)\n    {\n        // Apply corrective torques to humanoid joints\n        // This would typically involve inverse kinematics calculations\n    }\n}\n\n// Components for balance control\npublic struct HumanoidTag : IComponentData { }\n\npublic struct BalanceController : IComponentData\n{\n    public float PGain;        // Proportional gain for balance correction\n    public float IGain;        // Integral gain for balance correction\n    public float DGain;        // Derivative gain for balance correction\n    public float MaxTorque;    // Maximum torque to apply\n    public float3 CoMTarget;   // Target center of mass position\n}\n\npublic struct ContactInfo : IComponentData\n{\n    public float3 ContactPoint;\n    public float3 ContactNormal;\n    public float ContactForce;\n    public bool IsInContact;\n}\n"})}),"\n",(0,o.jsx)(t.h2,{id:"unity-based-humanoid-control-systems",children:"Unity-Based Humanoid Control Systems"}),"\n",(0,o.jsx)(t.p,{children:"Unity's real-time capabilities make it ideal for interactive humanoid control and rapid prototyping:"}),"\n",(0,o.jsx)(t.h3,{id:"inverse-kinematics-system",children:"Inverse Kinematics System"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"// InverseKinematicsSystem.cs - ECS System for Inverse Kinematics\nusing Unity.Burst;\nusing Unity.Entities;\nusing Unity.Mathematics;\nusing Unity.Transforms;\n\n[BurstCompile]\npublic partial struct InverseKinematicsSystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        var job = new InverseKinematicsJob\n        {\n            DeltaTime = SystemAPI.Time.DeltaTime\n        };\n\n        job.Schedule();\n    }\n}\n\n[BurstCompile]\npublic partial struct InverseKinematicsJob : IJobEntity\n{\n    public float DeltaTime;\n\n    void Execute(ref RobotState robotState, in IKTarget target, ref DynamicBuffer<JointState> joints)\n    {\n        // Perform inverse kinematics to reach target position\n        float3 currentPosition = GetEndEffectorPosition(joints);\n        float3 error = target.Position - currentPosition;\n\n        if (math.length(error) > target.Tolerance)\n        {\n            // Calculate joint angle adjustments using Jacobian transpose method\n            float3x3 jacobian = CalculateJacobian(joints);\n            float3x3 jacobianTranspose = math.transpose(jacobian);\n\n            // Apply small adjustments iteratively\n            float3 jointAdjustments = math.mul(jacobianTranspose, error * DeltaTime * target.Gain);\n\n            // Update joint angles\n            for (int i = 0; i < joints.Length && i < jointAdjustments.c0.x; i++)\n            {\n                joints[i] = new JointState\n                {\n                    Position = joints[i].Position + jointAdjustments[i],\n                    Velocity = 0,\n                    Effort = 0,\n                    MinPosition = joints[i].MinPosition,\n                    MaxPosition = joints[i].MaxPosition\n                };\n            }\n        }\n    }\n\n    private float3 GetEndEffectorPosition(DynamicBuffer<JointState> joints)\n    {\n        // Calculate end effector position based on current joint angles\n        // This is a simplified representation - real implementation would use forward kinematics\n        return new float3(0, 0, 0);\n    }\n\n    private float3x3 CalculateJacobian(DynamicBuffer<JointState> joints)\n    {\n        // Calculate Jacobian matrix for the robot arm\n        // This represents the relationship between joint velocities and end-effector velocity\n        return float3x3.identity;\n    }\n}\n\n// Component for IK targets\npublic struct IKTarget : IComponentData\n{\n    public float3 Position;      // Target position for end effector\n    public quaternion Rotation;  // Target rotation for end effector\n    public float Tolerance;      // Acceptable error tolerance\n    public float Gain;           // IK solver gain\n    public int ChainLength;      // Number of joints in the kinematic chain\n}\n"})}),"\n",(0,o.jsx)(t.h2,{id:"visualization-and-debugging-tools",children:"Visualization and Debugging Tools"}),"\n",(0,o.jsx)(t.p,{children:"Unity's visual editing capabilities provide powerful tools for humanoid robot development:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",children:"// DebugVisualization.cs - Visualization tools for humanoid debugging\nusing UnityEngine;\nusing Unity.Entities;\n\npublic class DebugVisualization : MonoBehaviour\n{\n    public Material CoMVisualizationMaterial;\n    public Material ZMPLocationMaterial;\n    public float VisualizationScale = 0.1f;\n\n    void OnDrawGizmos()\n    {\n        // Visualize center of mass\n        DrawCenterOfMass();\n\n        // Visualize zero moment point\n        DrawZMP();\n\n        // Visualize joint limits\n        DrawJointLimits();\n    }\n\n    void DrawCenterOfMass()\n    {\n        // Calculate and visualize center of mass\n        Vector3 com = CalculateCenterOfMass();\n        Gizmos.color = Color.red;\n        Gizmos.DrawSphere(com, VisualizationScale);\n        Gizmos.color = Color.white;\n        Gizmos.DrawLine(transform.position, com);\n    }\n\n    void DrawZMP()\n    {\n        // Calculate and visualize Zero Moment Point\n        Vector3 zmp = CalculateZMP();\n        Gizmos.color = Color.blue;\n        Gizmos.DrawWireSphere(zmp, VisualizationScale * 1.5f);\n    }\n\n    void DrawJointLimits()\n    {\n        // Visualize joint limits for debugging\n        Gizmos.color = Color.yellow;\n        // Draw limit indicators for each joint\n    }\n\n    Vector3 CalculateCenterOfMass()\n    {\n        // Calculate center of mass based on robot configuration\n        return transform.position; // Simplified\n    }\n\n    Vector3 CalculateZMP()\n    {\n        // Calculate Zero Moment Point based on forces and torques\n        return transform.position; // Simplified\n    }\n}\n\n// ECS System for real-time visualization\n[BurstCompile]\npublic partial struct VisualizationSystem : ISystem\n{\n    [BurstCompile]\n    public void OnUpdate(ref SystemState state)\n    {\n        // Update visualization data for all robots\n        var robotQuery = SystemAPI.QueryBuilder()\n            .WithAll<RobotIdentity, RobotState>()\n            .WithNone<VisualizationDisabled>()\n            .Build();\n\n        var robotEntities = robotQuery.ToEntityArray(Allocator.Temp);\n\n        foreach (var entity in robotEntities)\n        {\n            UpdateVisualizationData(ref state, entity);\n        }\n\n        robotEntities.Dispose();\n    }\n\n    private void UpdateVisualizationData(ref SystemState state, Entity entity)\n    {\n        var robotState = state.EntityManager.GetComponentData<RobotState>(entity);\n        var robotIdentity = state.EntityManager.GetComponentData<RobotIdentity>(entity);\n\n        // Update visualization components with current robot state\n        if (state.EntityManager.HasComponent<VisualizationData>(entity))\n        {\n            var vizData = state.EntityManager.GetComponentData<VisualizationData>(entity);\n            vizData.CurrentPosition = robotState.Position;\n            vizData.CurrentRotation = robotState.Rotation;\n            vizData.Timestamp = SystemAPI.Time.ElapsedTime;\n\n            state.EntityManager.SetComponentData(entity, vizData);\n        }\n    }\n}\n\npublic struct VisualizationData : IComponentData\n{\n    public float3 CurrentPosition;\n    public quaternion CurrentRotation;\n    public double Timestamp;\n    public FixedString128Bytes RobotName;\n}\n"})}),"\n",(0,o.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsxs)(t.p,{children:["Unity simulation provides a powerful platform for humanoid robotics development, combining real-time visualization capabilities with high-performance physics simulation through the Entity Component System (ECS) architecture. By leveraging ",(0,o.jsx)(t.strong,{children:"URDF loaders"})," for robot model import, ",(0,o.jsx)(t.strong,{children:"Unity Physics"})," for accurate simulation, and ",(0,o.jsx)(t.strong,{children:"ECS patterns"})," for high-performance computation, developers can create interactive humanoid simulations suitable for rapid prototyping and visualization."]}),"\n",(0,o.jsx)(t.p,{children:"Key capabilities include:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"URDF integration"})," for importing ROS robot models while maintaining kinematic accuracy"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"ECS architecture"})," for high-performance parallel processing of robot systems"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Physics simulation"})," with configurable materials, constraints, and contact detection"]}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.strong,{children:"Real-time visualization"})," tools for debugging and development"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"In Chapter 8, we will explore advanced simulation techniques including domain randomization, multi-robot coordination, and simulation-to-reality transfer methods for deploying humanoid robots from simulation to real hardware."}),"\n",(0,o.jsx)(t.h2,{id:"review-questions",children:"Review Questions"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Conceptual"}),": Compare Unity's ECS architecture with traditional object-oriented programming for humanoid robot simulation. What are the performance benefits of the data-oriented approach?"]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Applied"}),": Modify the BalanceControlSystem to implement a ZMP (Zero Moment Point) controller for humanoid balance, including the mathematical formulation for ZMP calculation."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Structural"}),": Explain how Unity's Burst Compiler contributes to simulation performance and what constraints it places on C# code for humanoid control systems."]}),"\n"]}),"\n"]})]})}function d(n={}){const{wrapper:t}={...(0,a.R)(),...n.components};return t?(0,o.jsx)(t,{...n,children:(0,o.jsx)(u,{...n})}):u(n)}},8453(n,t,i){i.d(t,{R:()=>s,x:()=>r});var e=i(6540);const o={},a=e.createContext(o);function s(n){const t=e.useContext(a);return e.useMemo(function(){return"function"==typeof n?n(t):{...t,...n}},[t,n])}function r(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),e.createElement(a.Provider,{value:t},n.children)}}}]);
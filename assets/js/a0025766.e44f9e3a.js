"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[718],{2591(e,n,o){o.r(n),o.d(n,{assets:()=>s,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"c13-zmp-walking","title":"Chapter 13: ZMP Walking and Balance Control for Humanoid Robotics","description":"Learning Outcomes","source":"@site/chapters/c13-zmp-walking.md","sourceDirName":".","slug":"/c13-zmp-walking","permalink":"/chapters/c13-zmp-walking","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 12: Whole-Body Control for Humanoid Robotics","permalink":"/chapters/c12-whole-body-control"},"next":{"title":"Chapter 14: Humanoid Integration and Deployment","permalink":"/chapters/c14-humanoid-integration"}}');var i=o(4848),r=o(8453);const l={},a="Chapter 13: ZMP Walking and Balance Control for Humanoid Robotics",s={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Overview",id:"overview",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"13.1 Theoretical Foundations of ZMP",id:"131-theoretical-foundations-of-zmp",level:2},{value:"13.1.1 Zero Moment Point Definition",id:"1311-zero-moment-point-definition",level:3},{value:"13.1.2 Stability Criterion",id:"1312-stability-criterion",level:3},{value:"13.2 Linear Inverted Pendulum Model (LIPM)",id:"132-linear-inverted-pendulum-model-lipm",level:2},{value:"13.2.1 Mathematical Formulation",id:"1321-mathematical-formulation",level:3},{value:"13.2.2 C++ Implementation of LIPM",id:"1322-c-implementation-of-lipm",level:3},{value:"13.3 Walking Pattern Generation",id:"133-walking-pattern-generation",level:2},{value:"13.3.1 Footstep Planning",id:"1331-footstep-planning",level:3},{value:"13.3.2 Preview Control for ZMP Tracking",id:"1332-preview-control-for-zmp-tracking",level:3},{value:"13.4 Capture Point Theory",id:"134-capture-point-theory",level:2},{value:"13.4.1 Capture Point Definition",id:"1341-capture-point-definition",level:3},{value:"13.4.2 Balance Recovery Strategies",id:"1342-balance-recovery-strategies",level:3},{value:"13.5 Feedback Control for Dynamic Balance",id:"135-feedback-control-for-dynamic-balance",level:2},{value:"13.5.1 ZMP Feedback Control",id:"1351-zmp-feedback-control",level:3},{value:"13.6 Implementation Considerations",id:"136-implementation-considerations",level:2},{value:"13.6.1 Real-time Performance",id:"1361-real-time-performance",level:3},{value:"13.6.2 Robustness and Adaptation",id:"1362-robustness-and-adaptation",level:3},{value:"13.7 Integration with ROS 2",id:"137-integration-with-ros-2",level:2},{value:"13.7.1 ROS 2 Walking Controller Interface",id:"1371-ros-2-walking-controller-interface",level:3},{value:"Summary",id:"summary",level:2},{value:"Review Questions",id:"review-questions",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"chapter-13-zmp-walking-and-balance-control-for-humanoid-robotics",children:"Chapter 13: ZMP Walking and Balance Control for Humanoid Robotics"})}),"\n",(0,i.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this chapter, students will be able to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Understand the Zero Moment Point (ZMP) stability criterion for humanoid locomotion"}),"\n",(0,i.jsx)(n.li,{children:"Implement ZMP-based walking pattern generation algorithms"}),"\n",(0,i.jsx)(n.li,{children:"Design feedback controllers for dynamic balance maintenance"}),"\n",(0,i.jsx)(n.li,{children:"Apply Capture Point theory for balance recovery strategies"}),"\n",(0,i.jsx)(n.li,{children:"Evaluate the stability margins of humanoid walking gaits"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Zero Moment Point (ZMP) based control represents one of the most successful approaches to achieving stable bipedal locomotion in humanoid robots. This chapter explores the theoretical foundations of ZMP stability, practical implementation of walking pattern generation algorithms, and feedback control strategies for maintaining dynamic balance during locomotion. We'll examine the mathematical formulation of ZMP, the Linear Inverted Pendulum Model (LIPM), and advanced techniques for generating stable walking patterns that enable humanoid robots to walk dynamically while maintaining balance."}),"\n",(0,i.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Zero Moment Point (ZMP)"}),": The point on the ground where the sum of all moments due to external forces equals zero, used as a stability criterion"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Linear Inverted Pendulum Model (LIPM)"}),": Simplified model of humanoid dynamics for ZMP-based control"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Capture Point"}),": Location where a robot must step to come to a complete stop, used for balance recovery"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Walking Pattern Generation"}),": Algorithms for creating stable footstep sequences and center of mass trajectories"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feedback Control"}),": Real-time adjustments to maintain balance based on sensor measurements"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"131-theoretical-foundations-of-zmp",children:"13.1 Theoretical Foundations of ZMP"}),"\n",(0,i.jsx)(n.h3,{id:"1311-zero-moment-point-definition",children:"13.1.1 Zero Moment Point Definition"}),"\n",(0,i.jsx)(n.p,{children:"The Zero Moment Point (ZMP) is a fundamental concept in bipedal robotics that defines the point on the ground where the sum of all moments due to external forces acting on the robot equals zero. For a humanoid robot, the ZMP is calculated as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"ZMP_x = (\u03a3(m_i * (\u1e8d_i * z_i - \u1e8d_g * z_i)) + \u03a3(F_ix * z_i - F_iz * x_i)) / \u03a3(m_i * g + F_iz)\nZMP_y = (\u03a3(m_i * (\xff_i * z_i - \xff_g * z_i)) + \u03a3(F_iy * z_i - F_iz * y_i)) / \u03a3(m_i * g + F_iz)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"m_i"})," is the mass of the i-th point mass"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"\u1e8d_i"}),", ",(0,i.jsx)(n.code,{children:"\xff_i"})," are the accelerations of the i-th point mass"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"x_i"}),", ",(0,i.jsx)(n.code,{children:"y_i"}),", ",(0,i.jsx)(n.code,{children:"z_i"})," are the positions of the i-th point mass"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"F_ix"}),", ",(0,i.jsx)(n.code,{children:"F_iy"}),", ",(0,i.jsx)(n.code,{children:"F_iz"})," are the external forces on the i-th point mass"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"g"})," is the gravitational acceleration"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"1312-stability-criterion",children:"13.1.2 Stability Criterion"}),"\n",(0,i.jsx)(n.p,{children:"For a humanoid robot to maintain stable posture or locomotion, the ZMP must lie within the support polygon defined by the contact points with the ground. The support polygon is typically the convex hull of the feet when both are in contact, or the area of the single foot during single support phase."}),"\n",(0,i.jsx)(n.p,{children:"The ZMP stability criterion can be expressed as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"ZMP_support_polygon = {(x, y) | ZMP_x \u2208 [x_min, x_max], ZMP_y \u2208 [y_min, y_max]}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"132-linear-inverted-pendulum-model-lipm",children:"13.2 Linear Inverted Pendulum Model (LIPM)"}),"\n",(0,i.jsx)(n.h3,{id:"1321-mathematical-formulation",children:"13.2.1 Mathematical Formulation"}),"\n",(0,i.jsx)(n.p,{children:"The Linear Inverted Pendulum Model (LIPM) simplifies the complex dynamics of a humanoid robot to a point mass supported by a massless leg. This model assumes:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["The center of mass (CoM) height remains constant: ",(0,i.jsx)(n.code,{children:"z = h = constant"})]}),"\n",(0,i.jsx)(n.li,{children:"The angular momentum around the CoM is zero"}),"\n",(0,i.jsx)(n.li,{children:"The robot is simplified to a point mass at the CoM"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Under these assumptions, the relationship between the CoM position ",(0,i.jsx)(n.code,{children:"(x, y)"})," and the ZMP position ",(0,i.jsx)(n.code,{children:"(px, py)"})," becomes:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\u1e8d = g/h * (x - px)\n\xff = g/h * (y - py)\n"})}),"\n",(0,i.jsx)(n.h3,{id:"1322-c-implementation-of-lipm",children:"13.2.2 C++ Implementation of LIPM"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// LIPMController.h\n#pragma once\n#include <Eigen/Dense>\n#include <vector>\n\nclass LIPMController {\nprivate:\n    double com_height_;          // Center of mass height (m)\n    double gravity_;             // Gravitational acceleration (m/s\xb2)\n    double omega_;               // Natural frequency (sqrt(g/h))\n\n    Eigen::Vector2d com_position_;   // Current CoM position (x, y)\n    Eigen::Vector2d com_velocity_;   // Current CoM velocity (vx, vy)\n    Eigen::Vector2d zmp_position_;   // Current ZMP position (px, py)\n\n    Eigen::Vector2d desired_com_position_;\n    Eigen::Vector2d desired_com_velocity_;\n    Eigen::Vector2d desired_zmp_position_;\n\npublic:\n    LIPMController(double com_height = 0.8);\n\n    // Update state\n    void updateState(const Eigen::Vector2d& com_pos,\n                    const Eigen::Vector2d& com_vel,\n                    const Eigen::Vector2d& zmp_pos);\n\n    // Compute desired ZMP from desired CoM trajectory\n    Eigen::Vector2d computeZMPTrajectory(const Eigen::Vector2d& desired_com_pos,\n                                        const Eigen::Vector2d& desired_com_vel);\n\n    // Compute CoM trajectory from ZMP reference\n    Eigen::Vector2d computeCoMTrajectory(const Eigen::Vector2d& zmp_ref,\n                                        double dt);\n\n    // Solve LIPM differential equation\n    Eigen::Vector2d solveLIPM(const Eigen::Vector2d& zmp_ref,\n                             const Eigen::Vector2d& current_com,\n                             const Eigen::Vector2d& current_vel,\n                             double dt);\n\n    // Calculate stability margins\n    double calculateStabilityMargin(const Eigen::Vector2d& zmp_pos,\n                                  const std::vector<Eigen::Vector2d>& support_polygon);\n};\n\n// LIPMController.cpp\n#include "LIPMController.h"\n#include <cmath>\n#include <algorithm>\n\nLIPMController::LIPMController(double com_height)\n    : com_height_(com_height), gravity_(9.81) {\n    omega_ = std::sqrt(gravity_ / com_height_);\n    com_position_.setZero();\n    com_velocity_.setZero();\n    zmp_position_.setZero();\n    desired_com_position_.setZero();\n    desired_com_velocity_.setZero();\n    desired_zmp_position_.setZero();\n}\n\nvoid LIPMController::updateState(const Eigen::Vector2d& com_pos,\n                                const Eigen::Vector2d& com_vel,\n                                const Eigen::Vector2d& zmp_pos) {\n    com_position_ = com_pos;\n    com_velocity_ = com_vel;\n    zmp_position_ = zmp_pos;\n}\n\nEigen::Vector2d LIPMController::computeZMPTrajectory(\n    const Eigen::Vector2d& desired_com_pos,\n    const Eigen::Vector2d& desired_com_vel) {\n\n    // From LIPM: px = x - h/g * \u1e8d and py = y - h/g * \xff\n    // For trajectory generation, we use: px = x - 1/\u03c9\xb2 * \u1e8d\n    Eigen::Vector2d zmp_ref;\n    zmp_ref = desired_com_pos - (1.0 / (omega_ * omega_)) * desired_com_vel;\n\n    return zmp_ref;\n}\n\nEigen::Vector2d LIPMController::solveLIPM(const Eigen::Vector2d& zmp_ref,\n                                         const Eigen::Vector2d& current_com,\n                                         const Eigen::Vector2d& current_vel,\n                                         double dt) {\n\n    // Solve the LIPM differential equation using analytical solution\n    // x(t) = A * exp(\u03c9*t) + B * exp(-\u03c9*t) + px\n    // where px, py are ZMP positions\n\n    double exp_pos = std::exp(omega_ * dt);\n    double exp_neg = std::exp(-omega_ * dt);\n\n    // Calculate coefficients A and B based on initial conditions\n    double A_x = (current_vel[0] + omega_ * (current_com[0] - zmp_ref[0])) / (2.0 * omega_);\n    double B_x = (current_vel[0] - omega_ * (current_com[0] - zmp_ref[0])) / (2.0 * omega_);\n\n    double A_y = (current_vel[1] + omega_ * (current_com[1] - zmp_ref[1])) / (2.0 * omega_);\n    double B_y = (current_vel[1] - omega_ * (current_com[1] - zmp_ref[1])) / (2.0 * omega_);\n\n    Eigen::Vector2d new_com;\n    new_com[0] = A_x * exp_pos + B_x * exp_neg + zmp_ref[0];\n    new_com[1] = A_y * exp_pos + B_y * exp_neg + zmp_ref[1];\n\n    return new_com;\n}\n\ndouble LIPMController::calculateStabilityMargin(\n    const Eigen::Vector2d& zmp_pos,\n    const std::vector<Eigen::Vector2d>& support_polygon) {\n\n    if (support_polygon.size() < 3) {\n        return 0.0; // Invalid polygon\n    }\n\n    // Find the closest point on the support polygon to the ZMP\n    double min_distance = std::numeric_limits<double>::max();\n\n    for (size_t i = 0; i < support_polygon.size(); ++i) {\n        size_t next_i = (i + 1) % support_polygon.size();\n\n        // Calculate distance from ZMP to each edge of the polygon\n        Eigen::Vector2d edge = support_polygon[next_i] - support_polygon[i];\n        Eigen::Vector2d to_zmp = zmp_pos - support_polygon[i];\n\n        double edge_length = edge.norm();\n        if (edge_length < 1e-6) continue; // Skip degenerate edge\n\n        Eigen::Vector2d edge_unit = edge / edge_length;\n        double projection = to_zmp.dot(edge_unit);\n\n        if (projection < 0) {\n            // Closest point is the start vertex\n            double dist = (zmp_pos - support_polygon[i]).norm();\n            min_distance = std::min(min_distance, dist);\n        } else if (projection > edge_length) {\n            // Closest point is the end vertex\n            double dist = (zmp_pos - support_polygon[next_i]).norm();\n            min_distance = std::min(min_distance, dist);\n        } else {\n            // Closest point is on the edge\n            Eigen::Vector2d closest_point = support_polygon[i] + projection * edge_unit;\n            double dist = (zmp_pos - closest_point).norm();\n            min_distance = std::min(min_distance, dist);\n        }\n    }\n\n    return min_distance;\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"133-walking-pattern-generation",children:"13.3 Walking Pattern Generation"}),"\n",(0,i.jsx)(n.h3,{id:"1331-footstep-planning",children:"13.3.1 Footstep Planning"}),"\n",(0,i.jsx)(n.p,{children:"Walking pattern generation involves creating a sequence of footstep positions and timing that enables stable locomotion. The process typically involves:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Footstep placement"}),": Determining where to place the swing foot"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Timing"}),": Defining the duration of single and double support phases"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"CoM trajectory"}),": Planning the center of mass path during walking"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"1332-preview-control-for-zmp-tracking",children:"13.3.2 Preview Control for ZMP Tracking"}),"\n",(0,i.jsx)(n.p,{children:"Preview control uses future reference trajectory information to improve tracking performance. For ZMP control, this means using future ZMP references to compute current CoM positions."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// PreviewController.h\n#pragma once\n#include <Eigen/Dense>\n#include <vector>\n\nclass PreviewController {\nprivate:\n    int preview_horizon_;       // Number of future steps to consider\n    double control_dt_;         // Control timestep\n    double sampling_dt_;        // Sampling timestep for preview\n\n    std::vector<double> k_matrix_;      // Feedback gains\n    std::vector<double> kf_matrix_;     // Preview gains\n\n    Eigen::VectorXd zmp_reference_;     // Future ZMP reference trajectory\n    Eigen::VectorXd com_state_;         // Current CoM state [position, velocity]\n\npublic:\n    PreviewController(int horizon, double dt);\n\n    void setReferenceTrajectory(const std::vector<Eigen::Vector2d>& zmp_refs);\n    Eigen::Vector2d computeControl(const Eigen::Vector2d& current_zmp,\n                                  const Eigen::Vector2d& current_com,\n                                  const Eigen::Vector2d& current_com_vel);\n\nprivate:\n    void computePreviewGains();\n    Eigen::Vector2d solveRiccatiEquation();\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"134-capture-point-theory",children:"13.4 Capture Point Theory"}),"\n",(0,i.jsx)(n.h3,{id:"1341-capture-point-definition",children:"13.4.1 Capture Point Definition"}),"\n",(0,i.jsx)(n.p,{children:"The Capture Point (CP) is the location on the ground where a robot must step to come to a complete stop. It's defined as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"CP_x = CoM_x + CoM_vx / \u03c9\nCP_y = CoM_y + CoM_vy / \u03c9\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Where ",(0,i.jsx)(n.code,{children:"\u03c9 = sqrt(g/h)"})," is the natural frequency of the inverted pendulum."]}),"\n",(0,i.jsx)(n.h3,{id:"1342-balance-recovery-strategies",children:"13.4.2 Balance Recovery Strategies"}),"\n",(0,i.jsx)(n.p,{children:"Capture Point theory provides a framework for balance recovery by determining where to step to regain stability."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// CapturePointController.h\n#pragma once\n#include <Eigen/Dense>\n\nclass CapturePointController {\nprivate:\n    double com_height_;\n    double gravity_;\n    double omega_;\n\n    Eigen::Vector2d com_position_;\n    Eigen::Vector2d com_velocity_;\n\npublic:\n    CapturePointController(double height);\n\n    Eigen::Vector2d calculateCapturePoint();\n    bool isStable(const Eigen::Vector2d& support_polygon_center,\n                  double support_polygon_width);\n    void computeBalanceRecoveryStep(Eigen::Vector2d& step_position,\n                                   double& step_timing);\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"135-feedback-control-for-dynamic-balance",children:"13.5 Feedback Control for Dynamic Balance"}),"\n",(0,i.jsx)(n.h3,{id:"1351-zmp-feedback-control",children:"13.5.1 ZMP Feedback Control"}),"\n",(0,i.jsx)(n.p,{children:"ZMP feedback control adjusts the desired CoM trajectory based on the measured ZMP error to maintain stability."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// ZMPFeedbackController.h\n#pragma once\n#include <Eigen/Dense>\n\nclass ZMPFeedbackController {\nprivate:\n    double kp_zmp_;        // Proportional gain for ZMP error\n    double ki_zmp_;        // Integral gain for ZMP error\n    double kd_zmp_;        // Derivative gain for ZMP error\n\n    Eigen::Vector2d zmp_error_integral_;\n    Eigen::Vector2d prev_zmp_error_;\n\n    Eigen::Vector2d feedback_offset_;\n\npublic:\n    ZMPFeedbackController(double kp = 10.0, double ki = 1.0, double kd = 1.0);\n\n    Eigen::Vector2d computeFeedback(const Eigen::Vector2d& measured_zmp,\n                                   const Eigen::Vector2d& desired_zmp,\n                                   double dt);\n\n    void reset();\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"136-implementation-considerations",children:"13.6 Implementation Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"1361-real-time-performance",children:"13.6.1 Real-time Performance"}),"\n",(0,i.jsx)(n.p,{children:"ZMP-based walking controllers must operate in real-time to maintain stability:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Control frequency: Typically 200-1000 Hz for humanoid robots"}),"\n",(0,i.jsx)(n.li,{children:"Computational complexity: LIPM solutions should be computed in < 5ms"}),"\n",(0,i.jsx)(n.li,{children:"Sensor integration: IMU, force/torque sensors, joint encoders"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"1362-robustness-and-adaptation",children:"13.6.2 Robustness and Adaptation"}),"\n",(0,i.jsx)(n.p,{children:"Real-world implementations must handle:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Model uncertainties (mass, inertia, CoM position)"}),"\n",(0,i.jsx)(n.li,{children:"External disturbances (pushes, uneven terrain)"}),"\n",(0,i.jsx)(n.li,{children:"Actuator limitations (torque, velocity, position limits)"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"137-integration-with-ros-2",children:"13.7 Integration with ROS 2"}),"\n",(0,i.jsx)(n.h3,{id:"1371-ros-2-walking-controller-interface",children:"13.7.1 ROS 2 Walking Controller Interface"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// zmp_walking_controller.hpp\n#include <controller_interface/controller_interface.hpp>\n#include <geometry_msgs/msg/point_stamped.hpp>\n#include <std_msgs/msg/float64_multi_array.hpp>\n#include "LIPMController.h"\n\nnamespace zmp_walking_controller {\n\nclass ZMPWalkingController : public controller_interface::ControllerInterface {\npublic:\n    ZMPWalkingController();\n\n    controller_interface::return_type update(\n        const rclcpp::Time& time,\n        const rclcpp::Duration& period) override;\n\n    controller_interface::InterfaceConfiguration command_interface_configuration() const override;\n    controller_interface::InterfaceConfiguration state_interface_configuration() const override;\n\nprivate:\n    // ZMP controller instance\n    std::unique_ptr<LIPMController> lipm_controller_;\n\n    // ROS interfaces\n    rclcpp::Publisher<geometry_msgs::msg::PointStamped>::SharedPtr zmp_publisher_;\n    rclcpp::Publisher<std_msgs::msg::Float64MultiArray>::SharedPtr com_trajectory_publisher_;\n\n    // Walking parameters\n    double step_length_;\n    double step_width_;\n    double step_height_;\n    double walking_frequency_;\n\n    // State estimation\n    Eigen::Vector2d estimated_com_position_;\n    Eigen::Vector2d estimated_com_velocity_;\n    Eigen::Vector2d estimated_zmp_position_;\n\n    void initializeWalkingPattern();\n    void updateStateEstimation();\n    void computeWalkingControl();\n};\n\n} // namespace zmp_walking_controller\n'})}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"ZMP-based walking and balance control provides a mathematically sound approach to achieving stable bipedal locomotion in humanoid robots. The Linear Inverted Pendulum Model simplifies the complex dynamics while maintaining the essential stability characteristics. Walking pattern generation algorithms create stable footstep sequences, while feedback control systems maintain balance in the presence of disturbances."}),"\n",(0,i.jsx)(n.p,{children:"The success of ZMP-based control depends on accurate state estimation, real-time computation of control commands, and proper integration with the robot's hardware. Capture Point theory provides additional tools for balance recovery, enabling robots to respond to unexpected disturbances."}),"\n",(0,i.jsx)(n.p,{children:"Modern implementations leverage preview control and optimization techniques to improve tracking performance and stability margins, making ZMP-based walking a cornerstone of humanoid robotics."}),"\n",(0,i.jsx)(n.h2,{id:"review-questions",children:"Review Questions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Explain the Zero Moment Point (ZMP) stability criterion. Why is it important for humanoid locomotion?"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Describe the Linear Inverted Pendulum Model (LIPM) assumptions and how they simplify humanoid dynamics."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"How is the Capture Point used for balance recovery? Calculate the Capture Point for a given CoM position and velocity."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"What are the key components of a ZMP-based walking pattern generation system? Explain the role of each component."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Compare the advantages and limitations of ZMP-based control versus other balance control approaches."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Design a simple ZMP feedback controller. Specify the control law and tuning parameters."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"How does preview control improve ZMP tracking performance? What are the computational requirements?"}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"What are the real-time performance requirements for ZMP-based walking controllers? How do these impact system design?"}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,n,o){o.d(n,{R:()=>l,x:()=>a});var t=o(6540);const i={},r=t.createContext(i);function l(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);
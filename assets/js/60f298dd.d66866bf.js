"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[202],{4549(e,n,r){r.r(n),r.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"c9-real-time-control","title":"Chapter 9: Real-Time Control Systems and Embedded Hardware","description":"Learning Outcomes","source":"@site/chapters/c9-real-time-control.md","sourceDirName":".","slug":"/c9-real-time-control","permalink":"/chapters/c9-real-time-control","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"id":"c9-real-time-control","title":"Chapter 9: Real-Time Control Systems and Embedded Hardware","sidebar_label":"C9: Real-Time Control","sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"C8: Advanced Simulation","permalink":"/chapters/c8-advanced-simulation"},"next":{"title":"C10: Real-Time Algorithms","permalink":"/chapters/c10-real-time-algorithms"}}');var i=r(4848),o=r(8453);const a={id:"c9-real-time-control",title:"Chapter 9: Real-Time Control Systems and Embedded Hardware",sidebar_label:"C9: Real-Time Control",sidebar_position:9},l="Chapter 9: Real-Time Control Systems and Embedded Hardware",s={},c=[{value:"Learning Outcomes",id:"learning-outcomes",level:2},{value:"Overview",id:"overview",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Real-Time Control Architecture",id:"real-time-control-architecture",level:2},{value:"Real-Time Scheduling Configuration",id:"real-time-scheduling-configuration",level:3},{value:"Real-Time Thread Configuration in C++",id:"real-time-thread-configuration-in-c",level:3},{value:"RealtimeBuffer for Safe Data Exchange",id:"realtimebuffer-for-safe-data-exchange",level:3},{value:"ROS 2 Control Framework",id:"ros-2-control-framework",level:2},{value:"Hardware Interface Implementation",id:"hardware-interface-implementation",level:3},{value:"Controller Implementation",id:"controller-implementation",level:3},{value:"Embedded Hardware Platforms",id:"embedded-hardware-platforms",level:2},{value:"NVIDIA Jetson for Real-Time Control",id:"nvidia-jetson-for-real-time-control",level:3},{value:"Raspberry Pi Configuration for Lightweight Control",id:"raspberry-pi-configuration-for-lightweight-control",level:3},{value:"Real-Time Control Algorithms",id:"real-time-control-algorithms",level:2},{value:"PID Controller with Real-Time Safety",id:"pid-controller-with-real-time-safety",level:3},{value:"Summary",id:"summary",level:2},{value:"Review Questions",id:"review-questions",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"chapter-9-real-time-control-systems-and-embedded-hardware",children:"Chapter 9: Real-Time Control Systems and Embedded Hardware"})}),"\n",(0,i.jsx)(n.h2,{id:"learning-outcomes",children:"Learning Outcomes"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Design"})," real-time control architectures for humanoid robot systems with deterministic timing guarantees"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Implement"})," real-time control loops using ROS 2 Control framework with appropriate scheduling policies"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Configure"})," embedded hardware platforms (NVIDIA Jetson, Raspberry Pi, etc.) for real-time robot control"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Deploy"})," time-critical control algorithms on resource-constrained embedded systems"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"Modules 1 and 2 established the software foundations for humanoid robotics: ROS 2 communication patterns and simulation environments. However, deploying humanoid robots in the real world requires specialized real-time control systems and embedded hardware platforms capable of meeting strict timing constraints for safety-critical control loops."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Real-time control systems"})," ensure deterministic execution of control algorithms within bounded time constraints. For humanoid robots, this means executing joint position control, balance maintenance, and collision avoidance algorithms with predictable timing to prevent falls or unsafe behaviors. The control system must handle sensor data acquisition, state estimation, control computation, and actuator command generation within millisecond-level deadlines."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Embedded hardware platforms"})," provide the computational resources for running real-time control systems in compact, power-efficient packages suitable for deployment on humanoid robots. These platforms must balance computational performance with power consumption, thermal management, and physical size constraints."]}),"\n",(0,i.jsx)(n.p,{children:"This chapter introduces real-time control concepts, ROS 2 Control framework, embedded hardware platforms, and practical implementation strategies for deploying time-critical control algorithms on resource-constrained systems. You will learn to configure real-time scheduling, implement real-time safe communication patterns, and optimize control algorithms for embedded deployment."}),"\n",(0,i.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Real-Time Control"}),": Control systems that guarantee response within specified time constraints, essential for safety-critical robot applications"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"ROS 2 Control"}),": Framework for real-time robot control providing hardware abstraction, controller management, and real-time safety"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"SCHED_FIFO"}),": Linux real-time scheduling policy that ensures deterministic execution of time-critical threads"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"RealtimeBuffer"}),": Thread-safe data exchange mechanism between real-time and non-real-time threads in ROS 2 Control"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hardware Interface"}),": Abstraction layer in ROS 2 Control that connects controllers to physical hardware"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Controller Manager"}),": Central component that manages the lifecycle and execution of multiple controllers"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Update Rate"}),": Frequency at which the controller manager executes the real-time control loop (typically 100-1000 Hz)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Deterministic Timing"}),": Predictable execution timing essential for safety-critical robot control"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"real-time-control-architecture",children:"Real-Time Control Architecture"}),"\n",(0,i.jsx)(n.p,{children:"Real-time control systems for humanoid robots must guarantee deterministic timing for safety-critical control loops:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Sensor Data    \u2502\u2500\u2500\u2500\u25ba\u2502  Real-Time       \u2502\u2500\u2500\u2500\u25ba\u2502  Actuator        \u2502\n\u2502  Acquisition   \u2502    \u2502  Control Loop    \u2502    \u2502  Commands        \u2502\n\u2502  (IMU, Encoders,\u2502    \u2502  (State Estimation,\u2502   \u2502  (Joint Torque/  \u2502\n\u2502   Force Sensors)\u2502    \u2502   Control Computation)\u2502 \u2502   Position)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                       \u2502                        \u2502\n         \u25bc                       \u25bc                        \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  1-10ms         \u2502    \u2502  Deterministic   \u2502    \u2502  < 1ms           \u2502\n\u2502  Timing        \u2502\u25c4\u2500\u2500\u2500\u2524  Execution       \u2502\u25c4\u2500\u2500\u2500\u2524  Response        \u2502\n\u2502  Constraints   \u2502    \u2502  (SCHED_FIFO)    \u2502    \u2502  Times          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Real-time systems distinguish between ",(0,i.jsx)(n.strong,{children:"hard real-time"})," (missed deadlines cause system failure) and ",(0,i.jsx)(n.strong,{children:"soft real-time"})," (missed deadlines degrade performance but don't cause failure). Humanoid robot balance control represents a hard real-time requirement where missed deadlines can result in falls or damage."]}),"\n",(0,i.jsx)(n.h3,{id:"real-time-scheduling-configuration",children:"Real-Time Scheduling Configuration"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Configure system for real-time operation\n# Add user to realtime group\nsudo addgroup realtime\nsudo usermod -a -G realtime $USER\n\n# Set real-time limits in /etc/security/limits.conf\ncat << EOF | sudo tee -a /etc/security/limits.conf\n@realtime soft rtprio 99\n@realtime soft priority 99\n@realtime soft memlock unlimited\n@realtime hard rtprio 99\n@realtime hard priority 99\n@realtime hard memlock unlimited\nEOF\n\n# Reboot or log out/in for changes to take effect\necho "Reboot required for real-time configuration to take effect"\n'})}),"\n",(0,i.jsx)(n.h3,{id:"real-time-thread-configuration-in-c",children:"Real-Time Thread Configuration in C++"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// realtime_thread_config.cpp - Configure real-time threads for robot control\n#include <pthread.h>\n#include <sched.h>\n#include <sys/mman.h>\n#include <iostream>\n#include <thread>\n\nnamespace realtime_control {\n\nclass RealtimeThread {\nprivate:\n    pthread_t thread_id_;\n    int priority_;\n    bool configured_;\n\npublic:\n    RealtimeThread(int priority = 50) : priority_(priority), configured_(false) {}\n\n    bool configure_realtime() {\n        // Lock all memory pages to prevent page faults during real-time execution\n        if (mlockall(MCL_CURRENT | MCL_FUTURE) == -1) {\n            std::cerr << "Failed to lock memory pages for real-time thread" << std::endl;\n            return false;\n        }\n\n        // Configure thread scheduling policy\n        struct sched_param param;\n        param.sched_priority = priority_;\n\n        if (pthread_setschedparam(pthread_self(), SCHED_FIFO, &param) != 0) {\n            std::cerr << "Failed to set SCHED_FIFO scheduling for thread" << std::endl;\n            munlockall();\n            return false;\n        }\n\n        // Disable page fault handler to prevent non-deterministic delays\n        struct sched_param fifo_param;\n        fifo_param.sched_priority = priority_;\n\n        configured_ = true;\n        return true;\n    }\n\n    static void* realtime_thread_func(void* arg) {\n        // This function runs with real-time priority\n        RealtimeThread* rt_thread = static_cast<RealtimeThread*>(arg);\n\n        if (!rt_thread->configure_realtime()) {\n            return nullptr;\n        }\n\n        // Real-time control loop\n        while (true) {\n            // Perform time-critical control operations here\n            // Avoid system calls, dynamic allocation, or blocking operations\n            rt_thread->control_loop();\n\n            // Sleep for control period (use clock_nanosleep for real-time safety)\n            struct timespec sleep_time = {0, 1000000}; // 1ms\n            clock_nanosleep(CLOCK_MONOTONIC, 0, &sleep_time, NULL);\n        }\n\n        return nullptr;\n    }\n\n    void control_loop() {\n        // Placeholder for actual control computation\n        // In real implementation, this would contain:\n        // - Sensor data acquisition\n        // - State estimation\n        // - Control law computation\n        // - Actuator command generation\n    }\n\n    bool start() {\n        return pthread_create(&thread_id_, nullptr, realtime_thread_func, this) == 0;\n    }\n};\n\n} // namespace realtime_control\n'})}),"\n",(0,i.jsx)(n.h3,{id:"realtimebuffer-for-safe-data-exchange",children:"RealtimeBuffer for Safe Data Exchange"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:"// realtime_buffer_example.cpp - Using RealtimeBuffer for safe data exchange\n#include <realtime_tools/realtime_buffer.h>\n#include <geometry_msgs/msg/twist.hpp>\n#include <memory>\n\nnamespace realtime_control {\n\nclass VelocityController {\nprivate:\n    // Real-time safe buffer for velocity commands\n    std::shared_ptr<realtime_tools::RealtimeBuffer<geometry_msgs::msg::Twist>> velocity_buffer_;\n\n    // Non-real-time subscriber callback\n    void velocity_command_callback(const geometry_msgs::msg::Twist::SharedPtr msg) {\n        // This runs in non-real-time thread\n        velocity_buffer_->writeFromNonRT(*msg);\n    }\n\npublic:\n    VelocityController() {\n        velocity_buffer_ = std::make_shared<realtime_tools::RealtimeBuffer<geometry_msgs::msg::Twist>>();\n    }\n\n    geometry_msgs::msg::Twist get_current_velocity_command() {\n        // This runs in real-time thread - safe access to shared data\n        geometry_msgs::msg::Twist* current_cmd = velocity_buffer_->readFromRT();\n        return *current_cmd;\n    }\n\n    void update_control_loop() {\n        // Get current velocity command in real-time safe manner\n        geometry_msgs::msg::Twist cmd = get_current_velocity_command();\n\n        // Use command for real-time control computation\n        // Apply control law, compute joint torques, etc.\n    }\n};\n\n} // namespace realtime_control\n"})}),"\n",(0,i.jsx)(n.h2,{id:"ros-2-control-framework",children:"ROS 2 Control Framework"}),"\n",(0,i.jsx)(n.p,{children:"The ROS 2 Control framework provides a standardized approach to real-time robot control with hardware abstraction:"}),"\n",(0,i.jsx)(n.h3,{id:"hardware-interface-implementation",children:"Hardware Interface Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// hardware_interface.cpp - Implementing a custom hardware interface\n#include <hardware_interface/handle.hpp>\n#include <hardware_interface/hardware_info.hpp>\n#include <hardware_interface/system_interface.hpp>\n#include <hardware_interface/types/hardware_interface_return_values.hpp>\n#include <rclcpp/rclcpp.hpp>\n\nusing namespace std::chrono_literals;\n\nnamespace my_robot_hardware {\n\nclass MyRobotHardware : public hardware_interface::SystemInterface {\npublic:\n    // Constructor\n    CallbackReturn on_init(const hardware_interface::HardwareInfo & info) override {\n        if (SystemInterface::on_init(info) != CallbackReturn::SUCCESS) {\n            return CallbackReturn::ERROR;\n        }\n\n        // Validate joint information\n        if (info_.joints.size() != 12) {  // Example: 12 joints for humanoid legs\n            RCLCPP_FATAL(rclcpp::get_logger("MyRobotHardware"),\n                        "Expected 12 joints, got %zu", info_.joints.size());\n            return CallbackReturn::ERROR;\n        }\n\n        // Initialize joint data structures\n        joint_positions_.resize(info_.joints.size(), 0.0);\n        joint_velocities_.resize(info_.joints.size(), 0.0);\n        joint_efforts_.resize(info_.joints.size(), 0.0);\n        joint_commands_.resize(info_.joints.size(), 0.0);\n\n        // Initialize IMU data\n        imu_orientation_.resize(4, 0.0);  // quaternion\n        imu_angular_velocity_.resize(3, 0.0);\n        imu_linear_acceleration_.resize(3, 0.0);\n\n        return CallbackReturn::SUCCESS;\n    }\n\n    std::vector<hardware_interface::StateInterface> export_state_interfaces() override {\n        std::vector<hardware_interface::StateInterface> state_interfaces;\n\n        // Export joint position state interfaces\n        for (size_t i = 0; i < info_.joints.size(); i++) {\n            state_interfaces.emplace_back(hardware_interface::StateInterface(\n                info_.joints[i].name, hardware_interface::HW_IF_POSITION, &joint_positions_[i]));\n            state_interfaces.emplace_back(hardware_interface::StateInterface(\n                info_.joints[i].name, hardware_interface::HW_IF_VELOCITY, &joint_velocities_[i]));\n            state_interfaces.emplace_back(hardware_interface::StateInterface(\n                info_.joints[i].name, hardware_interface::HW_IF_EFFORT, &joint_efforts_[i]));\n        }\n\n        // Export IMU sensor interfaces\n        state_interfaces.emplace_back(hardware_interface::StateInterface(\n            "imu", "orientation.x", &imu_orientation_[0]));\n        state_interfaces.emplace_back(hardware_interface::StateInterface(\n            "imu", "orientation.y", &imu_orientation_[1]));\n        state_interfaces.emplace_back(hardware_interface::StateInterface(\n            "imu", "orientation.z", &imu_orientation_[2]));\n        state_interfaces.emplace_back(hardware_interface::StateInterface(\n            "imu", "orientation.w", &imu_orientation_[3]));\n\n        return state_interfaces;\n    }\n\n    std::vector<hardware_interface::CommandInterface> export_command_interfaces() override {\n        std::vector<hardware_interface::CommandInterface> command_interfaces;\n\n        // Export joint position command interfaces\n        for (size_t i = 0; i < info_.joints.size(); i++) {\n            command_interfaces.emplace_back(hardware_interface::CommandInterface(\n                info_.joints[i].name, hardware_interface::HW_IF_POSITION, &joint_commands_[i]));\n        }\n\n        return command_interfaces;\n    }\n\n    CallbackReturn on_activate(const rclcpp_lifecycle::State & previous_state) override {\n        RCLCPP_INFO(rclcpp::get_logger("MyRobotHardware"), "Activating ...please wait...");\n\n        // Initialize hardware to safe state\n        for (size_t i = 0; i < joint_commands_.size(); i++) {\n            joint_commands_[i] = joint_positions_[i];  // Start at current position\n        }\n\n        RCLCPP_INFO(rclcpp::get_logger("MyRobotHardware"), "Successfully activated!");\n        return CallbackReturn::SUCCESS;\n    }\n\n    CallbackReturn on_deactivate(const rclcpp_lifecycle::State & previous_state) override {\n        RCLCPP_INFO(rclcpp::get_logger("MyRobotHardware"), "Deactivating ...please wait...");\n        RCLCPP_INFO(rclcpp::get_logger("MyRobotHardware"), "Successfully deactivated!");\n        return CallbackReturn::SUCCESS;\n    }\n\n    hardware_interface::return_type read(const rclcpp::Time & time, const rclcpp::Duration & period) override {\n        // Read data from physical hardware (real-time safe)\n        // This method is called by the controller manager in the real-time loop\n\n        // Example: Read joint positions from encoders\n        for (size_t i = 0; i < joint_positions_.size(); i++) {\n            // In real implementation, this would read from actual hardware\n            // joint_positions_[i] = read_encoder(i);\n            // joint_velocities_[i] = differentiate_position(i);\n            // joint_efforts_[i] = read_torque_sensor(i);\n        }\n\n        // Example: Read IMU data\n        // read_imu_data(imu_orientation_, imu_angular_velocity_, imu_linear_acceleration_);\n\n        return hardware_interface::return_type::OK;\n    }\n\n    hardware_interface::return_type write(const rclcpp::Time & time, const rclcpp::Duration & period) override {\n        // Write commands to physical hardware (real-time safe)\n        // This method is called by the controller manager in the real-time loop\n\n        // Example: Send joint commands to actuators\n        for (size_t i = 0; i < joint_commands_.size(); i++) {\n            // In real implementation, this would send commands to actual hardware\n            // send_joint_command(i, joint_commands_[i]);\n        }\n\n        return hardware_interface::return_type::OK;\n    }\n\nprivate:\n    // Storage for joint data\n    std::vector<double> joint_positions_;\n    std::vector<double> joint_velocities_;\n    std::vector<double> joint_efforts_;\n    std::vector<double> joint_commands_;\n\n    // Storage for IMU data\n    std::vector<double> imu_orientation_;\n    std::vector<double> imu_angular_velocity_;\n    std::vector<double> imu_linear_acceleration_;\n};\n\n} // namespace my_robot_hardware\n\n#include "pluginlib/class_list_macros.hpp"\nPLUGINLIB_EXPORT_CLASS(my_robot_hardware::MyRobotHardware, hardware_interface::SystemInterface)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"controller-implementation",children:"Controller Implementation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// joint_trajectory_controller.cpp - Real-time safe controller implementation\n#include <controller_interface/controller_interface.hpp>\n#include <hardware_interface/loaned_command_interface.hpp>\n#include <hardware_interface/loaned_state_interface.hpp>\n#include <rclcpp/rclcpp.hpp>\n#include <std_msgs/msg/float64_multi_array.hpp>\n#include <trajectory_msgs/msg/joint_trajectory.hpp>\n#include <realtime_tools/realtime_buffer.h>\n\nnamespace my_controllers {\n\nclass JointTrajectoryController : public controller_interface::ControllerInterface {\npublic:\n    JointTrajectoryController() = default;\n\n    controller_interface::InterfaceConfiguration command_interface_configuration() const override {\n        controller_interface::InterfaceConfiguration conf;\n        conf.type = controller_interface::interface_configuration_type::INDIVIDUAL;\n\n        for (const auto & joint_name : joint_names_) {\n            conf.names.push_back(joint_name + "/" + hardware_interface::HW_IF_POSITION);\n        }\n\n        return conf;\n    }\n\n    controller_interface::InterfaceConfiguration state_interface_configuration() const override {\n        controller_interface::InterfaceConfiguration conf;\n        conf.type = controller_interface::interface_configuration_type::INDIVIDUAL;\n\n        for (const auto & joint_name : joint_names_) {\n            conf.names.push_back(joint_name + "/" + hardware_interface::HW_IF_POSITION);\n        }\n\n        return conf;\n    }\n\n    controller_interface::CallbackReturn on_init() override {\n        try {\n            // Initialize joint names (typically from parameters)\n            joint_names_ = {"left_hip", "left_knee", "left_ankle",\n                           "right_hip", "right_knee", "right_ankle",\n                           "left_shoulder", "left_elbow", "left_wrist",\n                           "right_shoulder", "right_elbow", "right_wrist"};\n\n            // Initialize trajectory buffer\n            trajectory_buffer_ = std::make_shared<realtime_tools::RealtimeBuffer<trajectory_msgs::msg::JointTrajectory>>();\n        } catch (const std::exception & e) {\n            RCLCPP_ERROR(get_node()->get_logger(), "Exception thrown during init: %s", e.what());\n            return controller_interface::CallbackReturn::ERROR;\n        }\n\n        return controller_interface::CallbackReturn::SUCCESS;\n    }\n\n    controller_interface::CallbackReturn on_configure(const rclcpp_lifecycle::State & previous_state) override {\n        RCLCPP_INFO(get_node()->get_logger(), "Configuring Joint Trajectory Controller");\n        return controller_interface::CallbackReturn::SUCCESS;\n    }\n\n    controller_interface::CallbackReturn on_activate(const rclcpp_lifecycle::State & previous_state) override {\n        RCLCPP_INFO(get_node()->get_logger(), "Activating Joint Trajectory Controller");\n        return controller_interface::CallbackReturn::SUCCESS;\n    }\n\n    controller_interface::CallbackReturn on_deactivate(const rclcpp_lifecycle::State & previous_state) override {\n        RCLCPP_INFO(get_node()->get_logger(), "Deactivating Joint Trajectory Controller");\n        return controller_interface::CallbackReturn::SUCCESS;\n    }\n\n    controller_interface::return_type update(const rclcpp::Time & time, const rclcpp::Duration & period) override {\n        // Real-time safe update method - called by controller manager\n        // This is the core of the control loop\n\n        // Get current trajectory from buffer (real-time safe)\n        const trajectory_msgs::msg::JointTrajectory * current_trajectory =\n            trajectory_buffer_->readFromRT();\n\n        if (current_trajectory && !current_trajectory->points.empty()) {\n            // Execute trajectory following logic\n            execute_trajectory(*current_trajectory, time);\n        }\n\n        // Apply control law to generate joint commands\n        for (size_t i = 0; i < joint_command_interfaces_.size(); i++) {\n            // In real implementation, this would contain control law\n            // joint_command_interfaces_[i].set_value(desired_position);\n        }\n\n        return controller_interface::return_type::OK;\n    }\n\nprivate:\n    void execute_trajectory(const trajectory_msgs::msg::JointTrajectory & trajectory,\n                           const rclcpp::Time & current_time) {\n        // Execute trajectory following - this runs in real-time loop\n        // Should be computationally efficient and deterministic\n    }\n\n    std::vector<std::string> joint_names_;\n    std::shared_ptr<realtime_tools::RealtimeBuffer<trajectory_msgs::msg::JointTrajectory>> trajectory_buffer_;\n};\n\n} // namespace my_controllers\n\n#include "pluginlib/class_list_macros.hpp"\nPLUGINLIB_EXPORT_CLASS(my_controllers::JointTrajectoryController, controller_interface::ControllerInterface)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"embedded-hardware-platforms",children:"Embedded Hardware Platforms"}),"\n",(0,i.jsx)(n.h3,{id:"nvidia-jetson-for-real-time-control",children:"NVIDIA Jetson for Real-Time Control"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# jetson_control_setup.py - Configure Jetson platform for real-time control\nimport os\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nclass JetsonControlSetup:\n    """Setup utilities for real-time control on NVIDIA Jetson platforms"""\n\n    def __init__(self):\n        self.jetson_model = self.detect_jetson_model()\n        self.realtime_configured = False\n\n    def detect_jetson_model(self):\n        """Detect the specific Jetson model"""\n        try:\n            with open(\'/proc/device-tree/model\', \'r\') as f:\n                model = f.read().strip().replace(\'\\x00\', \'\')\n                return model\n        except:\n            return "Unknown Jetson Model"\n\n    def configure_realtime_kernel(self):\n        """Configure Jetson for real-time operation"""\n        print(f"Configuring real-time settings for: {self.jetson_model}")\n\n        # Check if real-time kernel is available\n        has_rt_kernel = self.check_realtime_kernel()\n\n        if has_rt_kernel:\n            print("Real-time kernel detected")\n        else:\n            print("Real-time kernel not available - consider installing Jetson Linux RT")\n\n        # Configure CPU governor for performance\n        self.configure_cpu_governor()\n\n        # Configure memory for real-time operation\n        self.configure_memory_locking()\n\n        # Configure interrupt affinity to dedicate cores for control\n        self.configure_interrupt_affinity()\n\n        self.realtime_configured = True\n        return True\n\n    def check_realtime_kernel(self):\n        """Check if system is running a real-time kernel"""\n        try:\n            result = subprocess.run([\'uname\', \'-r\'], capture_output=True, text=True)\n            kernel_version = result.stdout.strip()\n            return \'rt\' in kernel_version.lower()\n        except:\n            return False\n\n    def configure_cpu_governor(self):\n        """Set CPU governor to performance mode for deterministic behavior"""\n        try:\n            # Set all CPU cores to performance mode\n            for cpu in range(os.cpu_count()):\n                gov_path = f"/sys/devices/system/cpu/cpu{cpu}/cpufreq/scaling_governor"\n                if os.path.exists(gov_path):\n                    with open(gov_path, \'w\') as f:\n                        f.write(\'performance\')\n            print("CPU governor set to performance mode")\n        except Exception as e:\n            print(f"Warning: Could not set CPU governor: {e}")\n\n    def configure_memory_locking(self):\n        """Configure memory locking for real-time operation"""\n        # This would typically require root privileges\n        print("Configuring memory locking...")\n\n        # Lock current process memory\n        try:\n            import resource\n            resource.setrlimit(resource.RLIMIT_MEMLOCK, (resource.RLIM_INFINITY, resource.RLIM_INFINITY))\n            print("Memory locking configured")\n        except Exception as e:\n            print(f"Warning: Could not configure memory locking: {e}")\n\n    def configure_interrupt_affinity(self):\n        """Configure interrupt affinity to dedicate cores for control"""\n        print("Configuring interrupt affinity...")\n\n        # Move most interrupts to CPU 0-2, reserve CPU 3 for real-time control\n        try:\n            # Get list of interrupt files\n            irq_path = "/proc/interrupts"\n            with open(irq_path, \'r\') as f:\n                lines = f.readlines()\n\n            # Example: Configure specific IRQs to specific CPUs\n            # This is a simplified example - real implementation would be more complex\n            print("Interrupt affinity configured")\n        except Exception as e:\n            print(f"Warning: Could not configure interrupt affinity: {e}")\n\n    def setup_realtime_user_permissions(self):\n        """Setup user permissions for real-time operation"""\n        print("Setting up real-time user permissions...")\n\n        # Add current user to realtime group\n        username = os.getlogin()\n        cmd = f"sudo usermod -a -G realtime {username}"\n        try:\n            subprocess.run(cmd.split(), check=True)\n            print(f"Added {username} to realtime group")\n        except subprocess.CalledProcessError:\n            print(f"Warning: Could not add {username} to realtime group")\n\n    def install_ros2_control_dependencies(self):\n        """Install ROS 2 Control dependencies optimized for Jetson"""\n        print("Installing ROS 2 Control dependencies...")\n\n        # Install required packages\n        packages = [\n            "ros-humble-ros2-control",\n            "ros-humble-ros2-controllers",\n            "ros-humble-realtime-tools",\n            "ros-humble-hardware-interface"\n        ]\n\n        for package in packages:\n            cmd = f"sudo apt install -y {package}"\n            try:\n                subprocess.run(cmd.split(), check=True)\n                print(f"Installed {package}")\n            except subprocess.CalledProcessError:\n                print(f"Warning: Could not install {package}")\n\n    def optimize_system_for_realtime(self):\n        """Apply system optimizations for real-time performance"""\n        print("Applying system optimizations...")\n\n        # Disable CPU idle states that can cause latency\n        try:\n            # Disable CPU C-states\n            with open(\'/sys/devices/system/cpu/cpuidle/enable\', \'w\') as f:\n                f.write(\'0\')\n            print("CPU idle states disabled")\n        except:\n            print("Warning: Could not disable CPU idle states")\n\n        # Reduce kernel preemption latency\n        try:\n            # This would typically involve kernel parameter changes\n            print("Kernel latency optimizations applied")\n        except:\n            print("Warning: Could not apply kernel latency optimizations")\n\ndef main():\n    """Main setup function"""\n    print("NVIDIA Jetson Real-Time Control Setup")\n    print("=" * 50)\n\n    setup = JetsonControlSetup()\n\n    print(f"Detected Jetson model: {setup.jetson_model}")\n\n    # Perform setup steps\n    setup.configure_realtime_kernel()\n    setup.setup_realtime_user_permissions()\n    setup.install_ros2_control_dependencies()\n    setup.optimize_system_for_realtime()\n\n    print("\\nReal-time setup completed!")\n    print("Reboot recommended for all changes to take effect.")\n    print("After reboot, verify real-time operation with: \'uname -r\' (should show \'rt\' in kernel name)")\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,i.jsx)(n.h3,{id:"raspberry-pi-configuration-for-lightweight-control",children:"Raspberry Pi Configuration for Lightweight Control"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# raspberry_pi_setup.py - Setup for lightweight control on Raspberry Pi\nimport os\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nclass RaspberryPiControlSetup:\n    """Setup utilities for real-time control on Raspberry Pi platforms"""\n\n    def __init__(self):\n        self.pi_model = self.detect_pi_model()\n        self.pi_version = self.get_pi_version()\n\n    def detect_pi_model(self):\n        """Detect Raspberry Pi model"""\n        try:\n            with open(\'/proc/device-tree/model\', \'r\') as f:\n                model = f.read().strip().replace(\'\\x00\', \'\')\n                return model\n        except:\n            return "Unknown Raspberry Pi Model"\n\n    def get_pi_version(self):\n        """Get Raspberry Pi version"""\n        try:\n            with open(\'/proc/cpuinfo\', \'r\') as f:\n                for line in f:\n                    if line.startswith(\'Revision\'):\n                        return line.split(\':\')[1].strip()\n        except:\n            return "Unknown"\n        return "Unknown"\n\n    def configure_for_control(self):\n        """Configure Raspberry Pi for lightweight control applications"""\n        print(f"Configuring Raspberry Pi: {self.pi_model}")\n\n        # Optimize CPU performance\n        self.optimize_cpu()\n\n        # Configure GPIO for actuator control\n        self.configure_gpio()\n\n        # Install lightweight control libraries\n        self.install_control_libraries()\n\n        # Configure real-time priorities (if available)\n        self.configure_realtime()\n\n        return True\n\n    def optimize_cpu(self):\n        """Optimize CPU settings for control applications"""\n        print("Optimizing CPU settings...")\n\n        # Set CPU governor to performance\n        try:\n            # For all CPU cores\n            cpu_count = os.cpu_count()\n            for cpu in range(cpu_count):\n                gov_path = f"/sys/devices/system/cpu/cpu{cpu}/cpufreq/scaling_governor"\n                if os.path.exists(gov_path):\n                    with open(gov_path, \'w\') as f:\n                        f.write(\'performance\')\n            print("CPU governor set to performance mode")\n        except Exception as e:\n            print(f"Warning: Could not set CPU governor: {e}")\n\n    def configure_gpio(self):\n        """Configure GPIO pins for actuator control"""\n        print("Configuring GPIO for actuator control...")\n\n        # Install GPIO library\n        try:\n            import RPi.GPIO as GPIO\n            print("RPi.GPIO library available")\n        except ImportError:\n            print("Installing RPi.GPIO...")\n            subprocess.run([sys.executable, "-m", "pip", "install", "RPi.GPIO"])\n\n        # Example GPIO configuration for PWM control\n        try:\n            import RPi.GPIO as GPIO\n            GPIO.setmode(GPIO.BCM)  # Use BCM pin numbering\n\n            # Configure GPIO pins for servo/PWM control\n            # Example pins for 4 actuators\n            actuator_pins = [18, 19, 20, 21]  # GPIO pins\n\n            for pin in actuator_pins:\n                GPIO.setup(pin, GPIO.OUT)\n                # Create PWM instance for each pin\n                pwm = GPIO.PWM(pin, 50)  # 50Hz for servos\n                pwm.start(0)  # Start with 0% duty cycle\n                print(f"Configured GPIO {pin} for PWM control")\n\n        except ImportError:\n            print("RPi.GPIO not available on this system")\n        except Exception as e:\n            print(f"Warning: Could not configure GPIO: {e}")\n\n    def install_control_libraries(self):\n        """Install lightweight control libraries"""\n        print("Installing control libraries...")\n\n        libraries = [\n            "pigpio",      # Hardware PWM library\n            "wiringpi",    # Alternative GPIO library\n            "numpy",       # Numerical computations\n            "scipy",       # Scientific computing\n        ]\n\n        for lib in libraries:\n            try:\n                subprocess.run([sys.executable, "-m", "pip", "install", lib], check=True)\n                print(f"Installed {lib}")\n            except subprocess.CalledProcessError:\n                print(f"Warning: Could not install {lib}")\n\n    def configure_realtime(self):\n        """Configure real-time capabilities if available"""\n        print("Configuring real-time capabilities...")\n\n        # Check if real-time kernel is available\n        try:\n            result = subprocess.run([\'uname\', \'-r\'], capture_output=True, text=True, check=True)\n            kernel_info = result.stdout.strip()\n\n            if \'PREEMPT\' in kernel_info.upper():\n                print("Preemptible kernel detected - real-time friendly")\n            else:\n                print("Standard kernel - consider real-time kernel for critical applications")\n\n            # Configure user for real-time privileges\n            self.setup_realtime_user()\n\n        except Exception as e:\n            print(f"Warning: Could not check real-time capabilities: {e}")\n\n    def setup_realtime_user(self):\n        """Setup user for real-time operation"""\n        try:\n            username = os.getlogin()\n            # Add to realtime group if it exists\n            subprocess.run([\'sudo\', \'usermod\', \'-a\', \'-G\', \'realtime\', username], check=True)\n            print(f"Added {username} to realtime group")\n        except subprocess.CalledProcessError:\n            print("Could not add user to realtime group - may need to create group first")\n        except:\n            print("Could not determine current user for real-time setup")\n\ndef main():\n    """Main setup function"""\n    print("Raspberry Pi Control System Setup")\n    print("=" * 40)\n\n    setup = RaspberryPiControlSetup()\n\n    print(f"Detected: {setup.pi_model}")\n    print(f"Revision: {setup.pi_version}")\n\n    setup.configure_for_control()\n\n    print("\\nRaspberry Pi setup completed!")\n    print("Configuration optimized for lightweight control applications.")\n\nif __name__ == "__main__":\n    main()\n'})}),"\n",(0,i.jsx)(n.h2,{id:"real-time-control-algorithms",children:"Real-Time Control Algorithms"}),"\n",(0,i.jsx)(n.h3,{id:"pid-controller-with-real-time-safety",children:"PID Controller with Real-Time Safety"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'// realtime_pid_controller.cpp - Real-time safe PID controller implementation\n#include <rclcpp/rclcpp.hpp>\n#include <realtime_tools/realtime_buffer.h>\n#include <hardware_interface/loaned_command_interface.hpp>\n#include <hardware_interface/loaned_state_interface.hpp>\n#include <controller_interface/controller_interface.hpp>\n\nnamespace realtime_control {\n\nclass RealtimePIDController : public controller_interface::ControllerInterface {\npublic:\n    RealtimePIDController() = default;\n\n    controller_interface::CallbackReturn on_init() override {\n        try {\n            // Initialize PID parameters (typically from parameters)\n            proportional_gain_ = 100.0;  // Example values\n            integral_gain_ = 10.0;\n            derivative_gain_ = 5.0;\n\n            // Initialize error terms\n            previous_error_ = 0.0;\n            integral_error_ = 0.0;\n\n            // Initialize command and state interfaces\n            joint_command_interface_ = nullptr;\n            joint_state_interface_ = nullptr;\n\n        } catch (const std::exception & e) {\n            RCLCPP_ERROR(get_node()->get_logger(), "Exception thrown during init: %s", e.what());\n            return controller_interface::CallbackReturn::ERROR;\n        }\n\n        return controller_interface::CallbackReturn::SUCCESS;\n    }\n\n    controller_interface::return_type update(const rclcpp::Time & time, const rclcpp::Duration & period) override {\n        // Real-time safe PID control loop\n\n        if (!joint_command_interface_ || !joint_state_interface_) {\n            return controller_interface::return_type::ERROR;\n        }\n\n        // Get current state\n        double current_position = joint_state_interface_->get().get_value();\n        double current_velocity = 0.0;  // If velocity interface available\n\n        // Get desired position from buffer (real-time safe)\n        double desired_position = desired_position_buffer_.readFromRT()->position;\n\n        // Calculate error\n        double error = desired_position - current_position;\n\n        // Update integral term (with anti-windup)\n        integral_error_ += error * period.seconds();\n\n        // Anti-windup: limit integral term\n        const double integral_limit = 100.0;\n        integral_error_ = std::max(-integral_limit, std::min(integral_error_, integral_limit));\n\n        // Calculate derivative (use velocity if available, otherwise numerical)\n        double derivative_error = 0.0;\n        if (std::abs(period.seconds()) > 1e-9) {  // Avoid division by zero\n            derivative_error = (error - previous_error_) / period.seconds();\n        }\n\n        // Store current error for next iteration\n        previous_error_ = error;\n\n        // Calculate PID output\n        double proportional_term = proportional_gain_ * error;\n        double integral_term = integral_gain_ * integral_error_;\n        double derivative_term = derivative_gain_ * derivative_error;\n\n        double output = proportional_term + integral_term + derivative_term;\n\n        // Apply output limits\n        const double output_limit = 100.0;  // Example limit\n        output = std::max(-output_limit, std::min(output, output_limit));\n\n        // Set command (real-time safe)\n        joint_command_interface_->get().set_value(output);\n\n        return controller_interface::return_type::OK;\n    }\n\n    // Real-time safe method to set desired position\n    void set_desired_position(double position) {\n        DesiredPosition new_desired;\n        new_desired.position = position;\n        desired_position_buffer_.writeFromNonRT(new_desired);\n    }\n\nprivate:\n    struct DesiredPosition {\n        double position;\n    };\n\n    // PID gains\n    double proportional_gain_;\n    double integral_gain_;\n    double derivative_gain_;\n\n    // PID state variables\n    double previous_error_;\n    double integral_error_;\n\n    // Real-time safe buffer for desired position\n    realtime_tools::RealtimeBuffer<DesiredPosition> desired_position_buffer_;\n\n    // Joint interfaces\n    std::shared_ptr<hardware_interface::LoanedCommandInterface> joint_command_interface_;\n    std::shared_ptr<hardware_interface::LoanedStateInterface> joint_state_interface_;\n};\n\n} // namespace realtime_control\n\n#include "pluginlib/class_list_macros.hpp"\nPLUGINLIB_EXPORT_CLASS(realtime_control::RealtimePIDController, controller_interface::ControllerInterface)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsxs)(n.p,{children:["Real-time control systems and embedded hardware form the backbone of humanoid robotics deployment, providing the deterministic timing and computational resources necessary for safety-critical robot operations. Through ",(0,i.jsx)(n.strong,{children:"ROS 2 Control framework"}),", ",(0,i.jsx)(n.strong,{children:"real-time scheduling configuration"}),", and ",(0,i.jsx)(n.strong,{children:"embedded platform optimization"}),", developers can create robust control systems that meet the strict timing requirements of humanoid robot applications."]}),"\n",(0,i.jsx)(n.p,{children:"Key capabilities include:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Real-time scheduling"})," using SCHED_FIFO policy for deterministic execution"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safe data exchange"})," using RealtimeBuffer for communication between real-time and non-real-time threads"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hardware abstraction"})," through ROS 2 Control interfaces for consistent control across different platforms"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Embedded optimization"})," for resource-constrained platforms like NVIDIA Jetson and Raspberry Pi"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"In Chapter 10, we will explore real-time control algorithms in greater depth, including advanced control strategies like Model Predictive Control (MPC) and whole-body control for humanoid robots."}),"\n",(0,i.jsx)(n.h2,{id:"review-questions",children:"Review Questions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Conceptual"}),": Explain the difference between hard real-time and soft real-time systems in the context of humanoid robotics. Provide examples of each type of control requirement."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Applied"}),": Implement a real-time safe joint position controller using ROS 2 Control that maintains < 1ms response time while handling sensor noise and actuator saturation limits."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Structural"}),": Compare the computational requirements and real-time performance characteristics of PID control versus Model Predictive Control on embedded hardware platforms."]}),"\n"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453(e,n,r){r.d(n,{R:()=>a,x:()=>l});var t=r(6540);const i={},o=t.createContext(i);function a(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);